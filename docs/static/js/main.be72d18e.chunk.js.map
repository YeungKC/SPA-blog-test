{"version":3,"sources":["compoment/not_found.tsx","api/types-and-hooks.ts","config.ts","hepler/caesar_cipher.ts","hepler/fetcher.ts","api/discussion.ts","hepler/time.ts","compoment/post_info.tsx","compoment/post.tsx","api/discussions.ts","compoment/post_item.tsx","compoment/posts.tsx","compoment/home.tsx","api/info.ts","compoment/info.tsx","compoment/footer.tsx","App.tsx","reportWebVitals.ts","api/discussion_categories.ts","index.tsx"],"names":["NotFound","location","useLocation","pathname","AuditLogOrderField","CheckAnnotationLevel","CheckConclusionState","CheckRunType","CheckStatusState","CollaboratorAffiliation","CommentAuthorAssociation","CommentCannotUpdateReason","CommitContributionOrderField","ContributionLevel","DefaultRepositoryPermissionField","DeploymentOrderField","DeploymentProtectionRuleType","DeploymentReviewState","DeploymentState","DeploymentStatusState","DiffSide","DiscussionOrderField","EnterpriseAdministratorInvitationOrderField","EnterpriseAdministratorRole","EnterpriseDefaultRepositoryPermissionSettingValue","EnterpriseEnabledDisabledSettingValue","EnterpriseEnabledSettingValue","EnterpriseMemberOrderField","EnterpriseMembersCanCreateRepositoriesSettingValue","EnterpriseMembersCanMakePurchasesSettingValue","EnterpriseServerInstallationOrderField","EnterpriseServerUserAccountEmailOrderField","EnterpriseServerUserAccountOrderField","EnterpriseServerUserAccountsUploadOrderField","EnterpriseServerUserAccountsUploadSyncState","EnterpriseUserAccountMembershipRole","EnterpriseUserDeployment","FileViewedState","FundingPlatform","GistOrderField","GistPrivacy","GitSignatureState","IdentityProviderConfigurationState","IpAllowListEnabledSettingValue","IpAllowListEntryOrderField","IpAllowListForInstalledAppsEnabledSettingValue","IssueCommentOrderField","IssueOrderField","IssueState","IssueTimelineItemsItemType","LabelOrderField","LanguageOrderField","LockReason","MergeStateStatus","MergeableState","MilestoneOrderField","MilestoneState","NotificationRestrictionSettingValue","OauthApplicationCreateAuditEntryState","OperationType","OrderDirection","OrgAddMemberAuditEntryPermission","OrgCreateAuditEntryBillingPlan","OrgRemoveBillingManagerAuditEntryReason","OrgRemoveMemberAuditEntryMembershipType","OrgRemoveMemberAuditEntryReason","OrgRemoveOutsideCollaboratorAuditEntryMembershipType","OrgRemoveOutsideCollaboratorAuditEntryReason","OrgUpdateDefaultRepositoryPermissionAuditEntryPermission","OrgUpdateMemberAuditEntryPermission","OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility","OrganizationInvitationRole","OrganizationInvitationType","OrganizationMemberRole","OrganizationMembersCanCreateRepositoriesSettingValue","OrganizationOrderField","PackageFileOrderField","PackageOrderField","PackageType","PackageVersionOrderField","PinnableItemType","PinnedDiscussionGradient","PinnedDiscussionPattern","ProjectCardArchivedState","ProjectCardState","ProjectColumnPurpose","ProjectOrderField","ProjectState","ProjectTemplate","PullRequestMergeMethod","PullRequestOrderField","PullRequestReviewCommentState","PullRequestReviewDecision","PullRequestReviewEvent","PullRequestReviewState","PullRequestState","PullRequestTimelineItemsItemType","PullRequestUpdateState","ReactionContent","ReactionOrderField","RefOrderField","ReleaseOrderField","RepoAccessAuditEntryVisibility","RepoAddMemberAuditEntryVisibility","RepoArchivedAuditEntryVisibility","RepoChangeMergeSettingAuditEntryMergeType","RepoCreateAuditEntryVisibility","RepoDestroyAuditEntryVisibility","RepoRemoveMemberAuditEntryVisibility","ReportedContentClassifiers","RepositoryAffiliation","RepositoryContributionType","RepositoryInteractionLimit","RepositoryInteractionLimitExpiry","RepositoryInteractionLimitOrigin","RepositoryInvitationOrderField","RepositoryLockReason","RepositoryOrderField","RepositoryPermission","RepositoryPrivacy","RepositoryVisibility","RequestableCheckStatusState","SamlDigestAlgorithm","SamlSignatureAlgorithm","SavedReplyOrderField","SearchType","SecurityAdvisoryEcosystem","SecurityAdvisoryIdentifierType","SecurityAdvisoryOrderField","SecurityAdvisorySeverity","SecurityVulnerabilityOrderField","SponsorOrderField","SponsorableOrderField","SponsorsActivityAction","SponsorsActivityOrderField","SponsorsActivityPeriod","SponsorsGoalKind","SponsorsTierOrderField","SponsorshipNewsletterOrderField","SponsorshipOrderField","SponsorshipPrivacy","StarOrderField","StatusState","SubscriptionState","TeamDiscussionCommentOrderField","TeamDiscussionOrderField","TeamMemberOrderField","TeamMemberRole","TeamMembershipType","TeamOrderField","TeamPrivacy","TeamRepositoryOrderField","TeamReviewAssignmentAlgorithm","TeamRole","TopicSuggestionDeclineReason","UserBlockDuration","UserStatusOrderField","VerifiableDomainOrderField","config","caesarOffset","encryptedToken","user","repository","perpage","orderBy","postCategoryId","labelsCount","rot","text","offset","split","map","char","String","fromCharCode","charCodeAt","join","token","fetchData","query","variables","a","fetch","method","headers","Authorization","body","JSON","stringify","res","json","errors","message","Error","data","LabelItemFragmentDoc","PostItemFragmentDoc","PostDetailFragmentDoc","UserDocument","useUserQuery","options","useQuery","fetcher","DiscussionCategoriesDocument","useDiscussionCategoriesQuery","DiscussionsDocument","useDiscussionsQuery","DiscussionDocument","useDiscussionQuery","cacheTime","months","formatTime","time","date","Date","day","getDate","index","getMonth","year","getFullYear","PostInfo","labels","Wrapper","wrap","length","margin","label","Label","styled","FlexBox","LabelWrapper","href","name","color","Time","Post","id","useParams","owner","number","Number","staleTime","isLoading","isError","discussion","nodes","column","Title","title","updatedAt","className","dangerouslySetInnerHTML","__html","bodyHTML","div","PostItem","to","padding","marginTop","justifyContent","createdAt","Link","Posts","useInfiniteQuery","params","categoryId","first","after","pageParam","field","UpdatedAt","CreatedAt","direction","Desc","getNextPageParam","lastPage","pageInfo","discussions","hasNextPage","endCursor","fetchNextPage","useMemo","pages","item","reduce","previousValue","currentValue","pageParams","ref","useRef","isBottomVisible","useIntersectionObserver","useEffect","width","node","Home","UserInfo","info","alignItems","as","Name","Description","description","url","websiteUrl","Divider","Footer","queryClient","QueryClient","App","QueryClientProvider","client","GlobalStyle","height","maxWidth","exact","path","createGlobalStyle","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","count","categories","console","log","ReactDOM","render","StrictMode","document","getElementById","window","encode","printDiscussionCategories"],"mappings":"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,E,mDAAAA,E,iCAAAA,E,mCAAAA,E,4DAAAA,E,2BAAAA,E,mCAAAA,E,qDAAAA,E,wCAAAA,E,+BAAAA,E,mCAAAA,E,qCAAAA,E,mCAAAA,E,iCAAAA,E,+BAAAA,E,uDAAAA,E,+BAAAA,E,uCAAAA,E,uCAAAA,Q,cA4EAC,K,uBAAAA,E,aAAAA,Q,cAqBAC,K,aAAAA,Q,cA8BAC,K,qBAAAA,E,oBAAAA,E,YAAAA,E,wBAAAA,Q,cA0FAC,K,gBAAAA,E,kBAAAA,E,cAAAA,E,cAAAA,E,cAAAA,E,qBAAAA,E,kBAAAA,E,qBAAAA,Q,cAoBAC,K,0BAAAA,E,sBAAAA,E,mBAAAA,Q,cAuBAC,K,uBAAAA,E,mBAAAA,E,gBAAAA,E,wBAAAA,Q,cAYAC,K,gBAAAA,E,aAAAA,Q,cAgDAC,K,oBAAAA,E,mBAAAA,Q,cAUAC,K,gBAAAA,E,mCAAAA,E,uBAAAA,Q,cAUAC,K,gBAAAA,E,gCAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,kBAAAA,E,qBAAAA,Q,cAkBAC,K,UAAAA,E,aAAAA,Q,cAUAC,K,cAAAA,E,aAAAA,Q,cAYAC,K,oBAAAA,E,6BAAAA,E,YAAAA,E,gCAAAA,E,uBAAAA,Q,cA0BAC,K,6DAAAA,E,6FAAAA,E,2EAAAA,Q,cAWAC,K,cAAAA,E,iCAAAA,E,6BAAAA,E,2CAAAA,E,6BAAAA,Q,cA0BAC,K,6DAAAA,E,6FAAAA,E,uDAAAA,E,0EAAAA,E,2CAAAA,Q,cAeAC,K,iCAAAA,E,2CAAAA,E,6BAAAA,Q,cAiBAC,K,6DAAAA,E,2EAAAA,Q,cAeAC,K,cAAAA,E,YAAAA,E,YAAAA,E,eAAAA,Q,cAaAC,K,cAAAA,E,aAAAA,Q,cASAC,K,UAAAA,E,oBAAAA,E,YAAAA,E,kBAAAA,E,mCAAAA,E,gBAAAA,E,iCAAAA,E,gCAAAA,Q,cAgCAC,K,cAAAA,E,iCAAAA,E,6BAAAA,E,uBAAAA,Q,cAYAC,K,cAAAA,E,aAAAA,Q,cAUAC,K,cAAAA,E,iBAAAA,Q,cAQAC,K,UAAAA,E,oBAAAA,E,oBAAAA,E,mBAAAA,Q,cAoBAC,K,uBAAAA,E,eAAAA,Q,cAwBAC,K,wBAAAA,Q,cAcAC,K,wBAAAA,Q,cASAC,K,gBAAAA,E,gBAAAA,E,cAAAA,E,UAAAA,E,cAAAA,E,YAAAA,E,qBAAAA,Q,cA6BAC,K,wBAAAA,Q,cAsBAC,K,YAAAA,E,cAAAA,E,4BAAAA,E,kBAAAA,E,2BAAAA,E,wBAAAA,E,YAAAA,E,aAAAA,Q,cAuBAC,K,qBAAAA,E,yBAAAA,E,qBAAAA,E,2BAAAA,E,wBAAAA,Q,cAcAC,K,uBAAAA,E,UAAAA,E,mBAAAA,E,uBAAAA,E,YAAAA,E,WAAAA,Q,cA2BAC,K,oBAAAA,E,4BAAAA,Q,cAmBAC,K,2BAAAA,E,qBAAAA,E,qBAAAA,Q,cAuBAC,K,YAAAA,E,yBAAAA,E,aAAAA,Q,cAoBAC,K,uBAAAA,E,YAAAA,E,wBAAAA,Q,cAYAC,K,gBAAAA,E,aAAAA,Q,cAQAC,K,wCAAAA,E,kDAAAA,E,2BAAAA,E,wBAAAA,Q,cA0BAC,K,cAAAA,E,gBAAAA,E,iBAAAA,Q,cAkBAC,K,uBAAAA,E,wBAAAA,Q,cAYAC,K,kBAAAA,E,uBAAAA,Q,cAUAC,K,oBAAAA,E,qCAAAA,E,kCAAAA,Q,cAWAC,K,kBAAAA,E,kBAAAA,E,kBAAAA,E,kCAAAA,Q,cAYAC,K,oBAAAA,E,qCAAAA,E,sBAAAA,E,sBAAAA,E,mBAAAA,Q,cAkBAC,K,gBAAAA,E,gBAAAA,E,aAAAA,Q,cAiBAC,K,6CAAAA,E,+BAAAA,E,oEAAAA,E,0EAAAA,E,mDAAAA,E,iDAAAA,E,mDAAAA,E,mDAAAA,E,6CAAAA,E,6CAAAA,E,sDAAAA,E,2BAAAA,E,4CAAAA,E,iCAAAA,E,0DAAAA,E,6CAAAA,E,8CAAAA,E,uCAAAA,E,+BAAAA,E,yEAAAA,E,uCAAAA,E,6CAAAA,E,sDAAAA,E,+CAAAA,E,6BAAAA,E,6BAAAA,E,2BAAAA,E,mDAAAA,E,iCAAAA,E,2BAAAA,E,mCAAAA,E,4DAAAA,E,2BAAAA,E,wCAAAA,E,oEAAAA,E,wCAAAA,E,qDAAAA,E,yDAAAA,E,6CAAAA,E,mCAAAA,E,qDAAAA,E,wCAAAA,E,+BAAAA,E,8CAAAA,E,8CAAAA,E,yDAAAA,E,mCAAAA,E,qCAAAA,E,mCAAAA,E,iCAAAA,E,+BAAAA,E,uDAAAA,E,+BAAAA,E,uCAAAA,E,uCAAAA,Q,cAkHAC,K,gBAAAA,E,aAAAA,Q,cAoBAC,K,oBAAAA,E,YAAAA,E,cAAAA,E,gBAAAA,E,cAAAA,E,gBAAAA,E,yBAAAA,E,sBAAAA,Q,cA8BAC,K,wBAAAA,Q,cAqBAC,K,4BAAAA,E,iCAAAA,Q,cAoEAC,K,uBAAAA,E,aAAAA,Q,cAuIAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAYAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,cAAAA,E,gBAAAA,E,iBAAAA,Q,cAqBAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAWAC,K,cAAAA,E,sBAAAA,E,qBAAAA,E,oBAAAA,E,oBAAAA,E,aAAAA,Q,cAiBAC,K,4BAAAA,E,yCAAAA,E,eAAAA,Q,cAkBAC,K,gBAAAA,E,cAAAA,E,2BAAAA,E,wCAAAA,E,yBAAAA,Q,cAmBAC,K,uCAAAA,E,qCAAAA,E,+BAAAA,E,oBAAAA,Q,cAYAC,K,iBAAAA,E,qBAAAA,E,mBAAAA,E,uBAAAA,E,wBAAAA,Q,cAcAC,K,4BAAAA,E,wBAAAA,E,aAAAA,Q,cAqBAC,K,uBAAAA,E,8BAAAA,Q,cAQAC,K,kBAAAA,E,sBAAAA,E,gBAAAA,E,iBAAAA,Q,cAqBAC,K,uBAAAA,E,YAAAA,E,qBAAAA,E,wBAAAA,E,wBAAAA,Q,cAeAC,K,cAAAA,E,oBAAAA,E,YAAAA,E,gBAAAA,E,eAAAA,Q,cAiBAC,K,kBAAAA,E,iBAAAA,Q,cAWAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cA8BAC,K,sBAAAA,E,yBAAAA,E,kBAAAA,E,gBAAAA,E,mBAAAA,Q,cAgDAC,K,YAAAA,E,gBAAAA,E,gBAAAA,E,iBAAAA,Q,cAYAC,K,mBAAAA,E,uBAAAA,E,uBAAAA,E,wBAAAA,Q,cAuBAC,K,wBAAAA,Q,cASAC,K,wBAAAA,E,cAAAA,E,wBAAAA,E,aAAAA,Q,cAcAC,K,oBAAAA,E,QAAAA,E,cAAAA,E,UAAAA,E,cAAAA,E,UAAAA,E,qBAAAA,Q,cA4BAC,K,UAAAA,E,aAAAA,Q,cAgBAC,K,2BAAAA,E,wBAAAA,Q,cAWAC,K,oBAAAA,E,YAAAA,E,UAAAA,E,qBAAAA,Q,cAuBAC,K,wBAAAA,Q,cA4EAC,K,cAAAA,E,uBAAAA,Q,cAoBAC,K,eAAAA,Q,cAOAC,K,6CAAAA,E,iCAAAA,E,+BAAAA,E,gBAAAA,E,8CAAAA,E,0BAAAA,Q,cA0BAC,K,uBAAAA,Q,cAMAC,K,UAAAA,E,UAAAA,E,cAAAA,E,aAAAA,Q,cAaAC,K,sDAAAA,E,2CAAAA,Q,cAqBAC,K,uBAAAA,E,8CAAAA,Q,cAsBAC,K,wBAAAA,Q,cAcAC,K,wBAAAA,Q,cAMAC,K,kBAAAA,E,iBAAAA,Q,cAgBAC,K,wBAAAA,Q,cAiBAC,K,cAAAA,E,oBAAAA,E,kBAAAA,E,kBAAAA,E,mBAAAA,Q,cAkCAC,K,kBAAAA,E,wBAAAA,E,6BAAAA,Q,cA8BAC,K,iBAAAA,Q,cAgBAC,K,wBAAAA,Q,cAiBAC,K,uBAAAA,E,eAAAA,Q,cAQAC,K,wBAAAA,E,iBAAAA,Q,cAQAC,K,UAAAA,E,uBAAAA,E,uBAAAA,Q,cAkBAC,K,aAAAA,Q,cAMAC,K,gBAAAA,E,mBAAAA,Q,cAoBAC,K,uBAAAA,E,YAAAA,E,wBAAAA,E,qBAAAA,E,wBAAAA,E,wBAAAA,Q,cAgBAC,K,2BAAAA,E,0BAAAA,Q,cAQAC,K,cAAAA,E,iBAAAA,Q,cAYAC,K,2BAAAA,E,yCAAAA,E,yBAAAA,E,4BAAAA,Q,cA+vBAC,K,iBAAAA,E,qBAAAA,E,mBAAAA,E,sBAAAA,E,wBAAAA,Q,cAgCAC,K,wBAAAA,Q,cAiBAC,K,uBAAAA,E,iBAAAA,Q,KAqEL,IAAMsC,GAAoB,gEAMpBC,GAAmB,wKAW1BD,IACOE,GAAqB,4MAc5BF,IACOG,GAAY,0IAUZC,GAAe,SAItBnB,EACAoB,GALsB,OAOxBC,aACE,CAAC,OAAQrB,GACTF,GAAyCoB,GAAclB,GACvDoB,IAEND,GAAaG,QAAU,SAACtB,GAAD,OAAmCF,GAAyCoB,GAAclB,IAC1G,IAAMuB,GAA4B,kPAY5BC,GAA+B,SAItCxB,EACAoB,GALsC,OAOxCC,aACE,CAAC,uBAAwBrB,GACzBF,GAAyEyB,GAA8BvB,GACvGoB,IAENI,GAA6BF,QAAU,SAACtB,GAAD,OAAmDF,GAAyEyB,GAA8BvB,IAC1L,IAAMyB,GAAmB,slBAwB1BT,IACOU,GAAsB,SAI7B1B,EACAoB,GAL6B,OAO/BC,aACE,CAAC,cAAerB,GAChBF,GAAuD2B,GAAqBzB,GAC5EoB,IAENM,GAAoBJ,QAAU,SAACtB,GAAD,OAA0CF,GAAuD2B,GAAqBzB,IAC7I,IAAM2B,GAAkB,+NAQzBV,IACOW,GAAqB,SAI5B5B,EACAoB,GAL4B,OAO9BC,aACE,CAAC,aAAcrB,GACfF,GAAqD6B,GAAoB3B,GACzEoB,IAENQ,GAAmBN,QAAU,SAACtB,GAAD,OAAyCF,GAAqD6B,GAAoB3B,IIztK/I,IAAM6B,GAAY,KCHlB,I,MAAMC,GAAS,kDAAkDxC,MAAM,KACxD,SAASyC,GAAWC,GACjC,IAAMC,EAAO,IAAIC,KAAKF,GAChBG,EAAMF,EAAKG,UACXC,EAAQJ,EAAKK,WACbC,EAAON,EAAKO,cAClB,MAAM,GAAN,OAAUV,GAAOO,GAAjB,YAA2BF,EAA3B,aAAmCI,GCArC,SAASE,GAAT,GAA2F,IAAvET,EAAsE,EAAtEA,KAAMU,EAAgE,EAAhEA,OACxB,OACE,eAACC,GAAD,CAASC,MAAI,EAAb,UACGb,GAAWC,GACX,CAACU,EAAOG,OAAS,GAAK,cAAC,KAAD,CAAKC,OAAO,QAAZ,eAA6BJ,EAAOnD,KAAI,SAACwD,GAAD,OAAW,cAACC,GAAD,CAAOlC,KAAMiC,WAK7F,IAAMJ,GAAUM,aAAOC,KAAPD,CAAH,8CAIb,SAASD,GAAT,GAAuD,IAAtClC,EAAqC,EAArCA,KACf,OACE,eAACqC,GAAD,CAAcC,KAAI,6BAAwB1E,GAAOG,KAA/B,YAAuCH,GAAOI,WAA9C,8CAA8FgC,EAAKuC,MAAQC,MAAOxC,EAAKwC,MAAzI,cACIxC,EAAKuC,QAKb,SAASE,GAAT,GAA2C,IAA3BvB,EAA0B,EAA1BA,KACd,OAAO,cAACW,GAAD,UAAUZ,GAAWC,KAG9B,I,GAAMmB,GAAeF,KAAOhD,EAAV,iNAGI,gBAAGqD,EAAH,EAAGA,MAAH,iBAAmBA,EAAnB,SC1BP,SAASE,KAAQ,IAAD,MACrBC,EAAOC,cAAPD,GADqB,EHFtB7B,GACL,CACE+B,MAAOjF,GAAOG,KACdwE,KAAM3E,GAAOI,WACb8E,OAAQC,OGAuCJ,GHC/CvE,YAAaR,GAAOQ,aAEtB,CACE4E,UAAWjC,GACXA,eGLIkC,EAFqB,EAErBA,UAAWjD,EAFU,EAEVA,KAAMkD,EAFI,EAEJA,QAEzB,GAAID,EACF,OAAO,wBAGT,GAAIC,EACF,OAAO,cAACpP,EAAD,IAGT,IAAMqP,EAAU,OAAGnD,QAAH,IAAGA,GAAH,UAAGA,EAAMhC,kBAAT,aAAG,EAAkBmF,WAC/BvB,EAAM,iBAAGuB,QAAH,IAAGA,GAAH,UAAGA,EAAYvB,cAAf,aAAG,EAAoBwB,aAAvB,QAAgC,GAE5C,OACE,eAAC,KAAD,CAASC,QAAM,EAAf,UACE,cAACC,GAAD,iBAAQH,QAAR,IAAQA,OAAR,EAAQA,EAAYI,QACpB,cAAC,KAAD,CAAKvB,OAAO,eAAZ,SACE,cAACL,GAAD,CAAUT,KAAMiC,EAAYK,UAAW5B,OAAQA,MAEjD,qBAAK6B,UAAU,gBAAgBC,wBAAyB,CAAEC,OAAM,OAAER,QAAF,IAAEA,OAAF,EAAEA,EAAYS,eAKpF,I,MAAMN,GAAQnB,KAAO0B,IAAV,kD,2BC9BL9C,GAAY,KCEH,SAAS+C,GAAT,GAAyD,IAAD,IAApC9D,EAAoC,EAApCA,KACjC,OACE,cAAC,GAAD,CAAS+D,GAAE,uBAAW/D,QAAX,IAAWA,OAAX,EAAWA,EAAM8C,QAA5B,SACE,eAAC,KAAD,CAASO,QAAM,EAAoBW,QAAQ,YAA3C,UACE,cAAC,GAAD,iBAAQhE,QAAR,IAAQA,OAAR,EAAQA,EAAMuD,QACd,eAAC,KAAD,CAASU,UAAU,OAAOC,eAAe,gBAAzC,UACE,cAAC,KAAD,iBACGlE,QADH,IACGA,GADH,UACGA,EAAM4B,cADT,iBACG,EAAcwB,aADjB,aACG,EAAqB3E,KAAI,SAACwD,GAAD,OACxB,cAACC,GAAD,CAAOlC,KAAMiC,SAGjB,cAACQ,GAAD,CAAMvB,KAAMlB,EAAMmE,iBARDnE,EAAM8C,UAejC,IAAMjB,GAAUM,aAAOiC,IAAPjC,CAAH,yKAUPmB,GAAQnB,KAAO0B,IAAV,kDC5BI,SAASQ,KAAS,IAAD,EFCvBC,aACL,SACA,SAACC,GACC,OAAO3D,GAAoBJ,QAAQ,CACjCqC,MAAOjF,GAAOG,KACdwE,KAAM3E,GAAOI,WACbwG,WAAY5G,GAAOO,eACnBsG,MAAO7G,GAAOK,QACdyG,MAAOH,EAAOI,UACdzG,QAAS,CACP0G,MAA0B,eAAnBhH,GAAOM,QAA2B/I,EAAqB0P,UAAY1P,EAAqB2P,UAC/FC,UAAWrN,GAAesN,MAE5B5G,YAAaR,GAAOQ,aAVfwC,KAaT,CACEoC,UAAWjC,GACXA,aACAkE,iBAAkB,SAACC,GAAc,IAAD,EACxBC,EAAQ,UAAGD,EAASlH,kBAAZ,aAAG,EAAqBoH,YAAYD,SAClD,OAAe,OAARA,QAAQ,IAARA,OAAA,EAAAA,EAAUE,eAAV,OAAyBF,QAAzB,IAAyBA,OAAzB,EAAyBA,EAAUG,cErBxCtF,EADsB,EACtBA,KAAMiD,EADgB,EAChBA,UAAWoC,EADK,EACLA,YAAaE,EADR,EACQA,cAChCH,EAAcI,mBAClB,yCAAMxF,QAAN,IAAMA,OAAN,EAAMA,EAAMyF,MAAMhH,KAAI,SAACiH,GAAD,uBAAUA,EAAK1H,kBAAf,aAAU,EAAiBoH,YAAYhC,SAAOuC,QAAO,SAACC,GAAD,IAAgBC,EAAhB,uDAA+B,GAA/B,oCAA2CD,QAA3C,IAA2CA,IAAiB,IAA5D,oBAAqEC,QAArE,IAAqEA,IAAgB,OAAM,WAAtK,QAA6K,KAE7K,QAAC7F,QAAD,IAACA,OAAD,EAACA,EAAM8F,aAEHC,EAAMC,iBAAO,MACbC,EAAkBC,aAAwBH,GAUhD,OARAI,qBAAU,WACJlD,GACCoC,GACAY,GACLV,MAEC,CAACtC,EAAWoC,EAAaY,EAAzB,OAA0CjG,QAA1C,IAA0CA,OAA1C,EAA0CA,EAAM8F,aAGjD,eAAC,KAAD,CAASzC,QAAM,EAAC+C,MAAM,OAAtB,UACGhB,EAAY3G,KAAI,SAAC4H,EAAM9E,GAAP,OACf,cAACuC,GAAD,CAA6B9D,KAAMqG,GAAnC,OAAeA,QAAf,IAAeA,OAAf,EAAeA,EAAMvD,WAEvB,qBAAKiD,IAAKA,OC3BD,SAASO,KACtB,OAAO,cAACjC,GAAD,I,+BCAHtD,GAAY,MCEH,SAASwF,KAAY,IAAD,EDC1BlG,GACL,CAAEtC,KAAMH,GAAOG,MACf,CACEiF,UAAWjC,GACXA,eCJIkC,EADyB,EACzBA,UAAWjD,EADc,EACdA,KACbwG,EAAI,OAAGxG,QAAH,IAAGA,OAAH,EAAGA,EAAMA,KAEnB,OAAIiD,IAAcuD,EACT,wBAIP,eAAC,KAAD,CAASnD,QAAM,EAACoD,WAAW,SAASC,GAAG,SAAvC,UACE,eAACC,GAAD,CAAM5C,GAAG,IAAT,UAAcyC,EAAKjE,KAAnB,aACA,cAACqE,GAAD,UAAcJ,EAAKK,cACnB,eAAC,KAAD,CAAS5C,UAAU,MAAnB,UACE,mBAAG3B,KAAMkE,EAAKM,IAAd,oBACCN,EAAKO,YAAc,CAAC,cAAC,KAAD,CAAKX,MAAM,QAAU,mBAAG9D,KAAMkE,EAAKO,WAAd,sBAE5C,cAACC,GAAD,OAKN,I,GAAML,GAAOxE,aAAOiC,IAAPjC,CAAH,wEAKJyE,GAAczE,KAAO0B,IAAV,kDAIXmD,GAAU7E,KAAO0B,IAAV,2GC/BE,SAASoD,KACtB,OACE,eAAC,GAAD,CAASP,GAAG,SAASxC,eAAe,SAASuC,WAAW,WAAWzC,QAAQ,iBAA3E,iCACoBpG,GAAOG,QAK/B,I,GAAM8D,GAAUM,aAAOC,KAAPD,CAAH,0DCDP+E,GAAc,IAAIC,KAET,SAASC,KACtB,OACE,eAACC,GAAA,EAAD,CAAqBC,OAAQJ,GAA7B,UACE,cAACK,GAAD,IACA,cAAC,KAAD,CAASrD,eAAe,SAASsD,OAAO,OAAxC,SACE,cAAC,IAAD,UACE,eAAC,KAAD,CAASnE,QAAM,EAAC+C,MAAM,OAAOnC,UAAU,OAAOwD,SAAS,QAAQzD,QAAQ,SAAvE,UACE,cAACuC,GAAD,IACA,eAAC,IAAD,WACE,cAAC,IAAD,CAAOmB,OAAK,EAACC,KAAK,IAAlB,SACE,cAACrB,GAAD,MAEF,cAAC,IAAD,CAAOqB,KAAK,kBAAZ,SACE,cAACjF,GAAD,MAEF,cAAC,IAAD,CAAOiF,KAAK,IAAZ,SACE,cAAC7T,EAAD,SAGJ,cAACmT,GAAD,cAQZ,IAAMM,GAAcK,aAAH,s0BC1BFC,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,gDCNC,2CAAA3I,EAAA,6DAAyCmJ,EAAzC,+BAAiD,GAAjD,SACY5H,GAA6BF,QAAQ,CAAEqC,MAAOjF,GAAOG,KAAMwE,KAAM3E,GAAOI,WAAYsK,MAAOA,GAA3F5H,GADZ,OACP6H,EADO,OAEbC,QAAQC,IAAIF,GAFC,4C,sBCKfG,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAACxB,GAAD,MAEFyB,SAASC,eAAe,SAM1BjB,KAQAkB,OAAOC,OhBlBQ,SAAC1K,GAAD,OAAkBD,GAAIC,EAAMV,GAAOC,egBmBlDkL,OAAOE,0BDxBQ,WAAf,mC","file":"static/js/main.be72d18e.chunk.js","sourcesContent":["import { useLocation } from \"react-router-dom\";\n\nexport default function NotFound() {\n  const location = useLocation();\n  return (\n    <div>\n      <h3>\n        No match for <code>{location.pathname}</code>\n      </h3>\n    </div>\n  );\n}\n","import { useQuery, UseQueryOptions } from 'react-query';\nimport { fetchData } from '../hepler/fetcher';\nexport type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** An ISO-8601 encoded date string. */\n  Date: any;\n  /** An ISO-8601 encoded UTC date string. */\n  DateTime: any;\n  /** A Git object ID. */\n  GitObjectID: any;\n  /** A fully qualified reference name (e.g. `refs/heads/master`). */\n  GitRefname: any;\n  /** Git SSH string */\n  GitSSHRemote: any;\n  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */\n  GitTimestamp: any;\n  /** A string containing HTML code. */\n  HTML: any;\n  /** An ISO-8601 encoded UTC date string with millisecond precision. */\n  PreciseDateTime: any;\n  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */\n  URI: any;\n  /** A valid x509 certificate string */\n  X509Certificate: any;\n};\n\n\n\n/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the invitation being accepted */\n  invitationId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n\n\n/** Autogenerated input type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignableInput = {\n  /** The id of the assignable object to add assignees to. */\n  assignableId: Scalars['ID'];\n  /** The id of users to add as assignees. */\n  assigneeIds: Array<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of AddComment */\nexport type AddCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddDiscussionComment */\nexport type AddDiscussionCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion to comment on. */\n  discussionId: Scalars['ID'];\n  /** The Node ID of the discussion comment within this discussion to reply to. */\n  replyToId?: Maybe<Scalars['ID']>;\n};\n\n\n/** Autogenerated input type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a member who will receive the support entitlement. */\n  login: Scalars['String'];\n};\n\n\n/** Autogenerated input type of AddLabelsToLabelable */\nexport type AddLabelsToLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ids of the labels to add. */\n  labelIds: Array<Scalars['ID']>;\n  /** The id of the labelable object to add labels to. */\n  labelableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddProjectCard */\nexport type AddProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The content of the card. Must be a member of the ProjectCardItem union */\n  contentId?: Maybe<Scalars['ID']>;\n  /** The note on the card. */\n  note?: Maybe<Scalars['String']>;\n  /** The Node ID of the ProjectColumn. */\n  projectColumnId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddProjectColumn */\nexport type AddProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the column. */\n  name: Scalars['String'];\n  /** The Node ID of the project. */\n  projectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The SHA of the commit to comment on. */\n  commitOID?: Maybe<Scalars['GitObjectID']>;\n  /** The comment id to reply to. */\n  inReplyTo?: Maybe<Scalars['ID']>;\n  /** The relative path of the file to comment on. */\n  path?: Maybe<Scalars['String']>;\n  /** The line index in the diff to comment on. */\n  position?: Maybe<Scalars['Int']>;\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: Maybe<Scalars['ID']>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>;\n};\n\n\n/** Autogenerated input type of AddPullRequestReview */\nexport type AddPullRequestReviewInput = {\n  /** The contents of the review body comment. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The review line comments. */\n  comments?: Maybe<Array<Maybe<DraftPullRequestReviewComment>>>;\n  /** The commit OID the review pertains to. */\n  commitOID?: Maybe<Scalars['GitObjectID']>;\n  /** The event to perform on the pull request review. */\n  event?: Maybe<PullRequestReviewEvent>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID'];\n  /** The review line comment threads. */\n  threads?: Maybe<Array<Maybe<DraftPullRequestReviewThread>>>;\n};\n\n\n/** Autogenerated input type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadInput = {\n  /** Body of the thread's first comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int'];\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: Maybe<Scalars['ID']>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>;\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: Maybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: Maybe<Scalars['Int']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: Maybe<DiffSide>;\n};\n\n\n/** Autogenerated input type of AddReaction */\nexport type AddReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the emoji to react with. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddStar */\nexport type AddStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Starrable ID to star. */\n  starrableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddUpvote */\nexport type AddUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion or comment to upvote. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of AddVerifiableDomain */\nexport type AddVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The URL of the domain */\n  domain: Scalars['URI'];\n  /** The ID of the owner to add the domain to */\n  ownerId: Scalars['ID'];\n};\n\n\n\n\n/** Autogenerated input type of ApproveDeployments */\nexport type ApproveDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Optional comment for approving deployments */\n  comment?: Maybe<Scalars['String']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the verifiable domain to approve. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ArchiveRepository */\nexport type ArchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the repository to mark as archived. */\n  repositoryId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n/** Ordering options for Audit Log connections. */\nexport type AuditLogOrder = {\n  /** The ordering direction. */\n  direction?: Maybe<OrderDirection>;\n  /** The field to order Audit Logs by. */\n  field?: Maybe<AuditLogOrderField>;\n};\n\n/** Properties by which Audit Log connections can be ordered. */\nexport enum AuditLogOrderField {\n  /** Order audit log entries by timestamp */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Autogenerated input type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the pending enterprise administrator invitation. */\n  invitationId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ChangeUserStatus */\nexport type ChangeUserStatusInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */\n  emoji?: Maybe<Scalars['String']>;\n  /** If set, the user status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars['DateTime']>;\n  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */\n  limitedAvailability?: Maybe<Scalars['Boolean']>;\n  /** A short description of your current status. */\n  message?: Maybe<Scalars['String']>;\n  /**\n   * The ID of the organization whose members will be allowed to see the status. If\n   * omitted, the status will be publicly visible.\n   */\n  organizationId?: Maybe<Scalars['ID']>;\n};\n\n\n\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationData = {\n  /** Represents an annotation's information level */\n  annotationLevel: CheckAnnotationLevel;\n  /** The location of the annotation */\n  location: CheckAnnotationRange;\n  /** A short description of the feedback for these lines of code. */\n  message: Scalars['String'];\n  /** The path of the file to add an annotation to. */\n  path: Scalars['String'];\n  /** Details about this annotation. */\n  rawDetails?: Maybe<Scalars['String']>;\n  /** The title that represents the annotation. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Represents an annotation's information level. */\nexport enum CheckAnnotationLevel {\n  /** An annotation indicating an inescapable error. */\n  Failure = 'FAILURE',\n  /** An annotation indicating some information. */\n  Notice = 'NOTICE',\n  /** An annotation indicating an ignorable error. */\n  Warning = 'WARNING'\n}\n\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationRange = {\n  /** The ending column of the range. */\n  endColumn?: Maybe<Scalars['Int']>;\n  /** The ending line of the range. */\n  endLine: Scalars['Int'];\n  /** The starting column of the range. */\n  startColumn?: Maybe<Scalars['Int']>;\n  /** The starting line of the range. */\n  startLine: Scalars['Int'];\n};\n\n\n/** The possible states for a check suite or run conclusion. */\nexport enum CheckConclusionState {\n  /** The check suite or run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check suite or run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check suite or run has failed. */\n  Failure = 'FAILURE',\n  /** The check suite or run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check suite or run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check suite or run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check suite or run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check suite or run has timed out. */\n  TimedOut = 'TIMED_OUT'\n}\n\n\n/** Possible further actions the integrator can perform. */\nexport type CheckRunAction = {\n  /** A short explanation of what this action would do. */\n  description: Scalars['String'];\n  /** A reference for the action on the integrator's system. */\n  identifier: Scalars['String'];\n  /** The text to be displayed on a button in the web UI. */\n  label: Scalars['String'];\n};\n\n\n\n/** The filters that are available when fetching check runs. */\nexport type CheckRunFilter = {\n  /** Filters the check runs created by this application ID. */\n  appId?: Maybe<Scalars['Int']>;\n  /** Filters the check runs by this name. */\n  checkName?: Maybe<Scalars['String']>;\n  /** Filters the check runs by this type. */\n  checkType?: Maybe<CheckRunType>;\n  /** Filters the check runs by this status. */\n  status?: Maybe<CheckStatusState>;\n};\n\n/** Descriptive details about the check run. */\nexport type CheckRunOutput = {\n  /** The annotations that are made as part of the check run. */\n  annotations?: Maybe<Array<CheckAnnotationData>>;\n  /** Images attached to the check run output displayed in the GitHub pull request UI. */\n  images?: Maybe<Array<CheckRunOutputImage>>;\n  /** The summary of the check run (supports Commonmark). */\n  summary: Scalars['String'];\n  /** The details of the check run (supports Commonmark). */\n  text?: Maybe<Scalars['String']>;\n  /** A title to provide for this check run. */\n  title: Scalars['String'];\n};\n\n/** Images attached to the check run output displayed in the GitHub pull request UI. */\nexport type CheckRunOutputImage = {\n  /** The alternative text for the image. */\n  alt: Scalars['String'];\n  /** A short image description. */\n  caption?: Maybe<Scalars['String']>;\n  /** The full URL of the image. */\n  imageUrl: Scalars['URI'];\n};\n\n/** The possible types of check runs. */\nexport enum CheckRunType {\n  /** Every check run available. */\n  All = 'ALL',\n  /** The latest check run. */\n  Latest = 'LATEST'\n}\n\n/** The possible states for a check suite or run status. */\nexport enum CheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run has been requested. */\n  Requested = 'REQUESTED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n\n\n\n\n/** The auto-trigger preferences that are available for check suites. */\nexport type CheckSuiteAutoTriggerPreference = {\n  /** The node ID of the application that owns the check suite. */\n  appId: Scalars['ID'];\n  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */\n  setting: Scalars['Boolean'];\n};\n\n\n\n/** The filters that are available when fetching check suites. */\nexport type CheckSuiteFilter = {\n  /** Filters the check suites created by this application ID. */\n  appId?: Maybe<Scalars['Int']>;\n  /** Filters the check suites by this name. */\n  checkName?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the labelable object to clear the labels from. */\n  labelableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CloneProject */\nexport type CloneProjectInput = {\n  /** The description of the project. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Whether or not to clone the source project's workflows. */\n  includeWorkflows: Scalars['Boolean'];\n  /** The name of the project. */\n  name: Scalars['String'];\n  /** The visibility of the project, defaults to false (private). */\n  public?: Maybe<Scalars['Boolean']>;\n  /** The source project to clone. */\n  sourceId: Scalars['ID'];\n  /** The owner ID to create the project under. */\n  targetOwnerId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A short description of the new repository. */\n  description?: Maybe<Scalars['String']>;\n  /**\n   * Whether to copy all branches from the template to the new repository. Defaults\n   * to copying only the default branch of the template.\n   */\n  includeAllBranches?: Maybe<Scalars['Boolean']>;\n  /** The name of the new repository. */\n  name: Scalars['String'];\n  /** The ID of the owner for the new repository. */\n  ownerId: Scalars['ID'];\n  /** The Node ID of the template repository. */\n  repositoryId: Scalars['ID'];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n\n\n/** Autogenerated input type of CloseIssue */\nexport type CloseIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the issue to be closed. */\n  issueId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ClosePullRequest */\nexport type ClosePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the pull request to be closed. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n\n/** Collaborators affiliation level with a subject. */\nexport enum CollaboratorAffiliation {\n  /** All collaborators the authenticated user can see. */\n  All = 'ALL',\n  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */\n  Direct = 'DIRECT',\n  /** All outside collaborators of an organization-owned subject. */\n  Outside = 'OUTSIDE'\n}\n\n\n/** A comment author association with repository. */\nexport enum CommentAuthorAssociation {\n  /** Author has been invited to collaborate on the repository. */\n  Collaborator = 'COLLABORATOR',\n  /** Author has previously committed to the repository. */\n  Contributor = 'CONTRIBUTOR',\n  /** Author has not previously committed to GitHub. */\n  FirstTimer = 'FIRST_TIMER',\n  /** Author has not previously committed to the repository. */\n  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',\n  /** Author is a placeholder for an unclaimed user. */\n  Mannequin = 'MANNEQUIN',\n  /** Author is a member of the organization that owns the repository. */\n  Member = 'MEMBER',\n  /** Author has no association with the repository. */\n  None = 'NONE',\n  /** Author is the owner of the repository. */\n  Owner = 'OWNER'\n}\n\n/** The possible errors that will prevent a user from updating a comment. */\nexport enum CommentCannotUpdateReason {\n  /** Unable to create comment because repository is archived. */\n  Archived = 'ARCHIVED',\n  /** You cannot update this comment */\n  Denied = 'DENIED',\n  /** You must be the author or have write access to this repository to update this comment. */\n  InsufficientAccess = 'INSUFFICIENT_ACCESS',\n  /** Unable to create comment because issue is locked. */\n  Locked = 'LOCKED',\n  /** You must be logged in to update this comment. */\n  LoginRequired = 'LOGIN_REQUIRED',\n  /** Repository is under maintenance. */\n  Maintenance = 'MAINTENANCE',\n  /** At least one email address must be verified to update this comment. */\n  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'\n}\n\n\n\n/** Specifies an author for filtering Git commits. */\nexport type CommitAuthor = {\n  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */\n  emails?: Maybe<Array<Scalars['String']>>;\n  /**\n   * ID of a User to filter by. If non-null, only commits authored by this user\n   * will be returned. This field takes precedence over emails.\n   */\n  id?: Maybe<Scalars['ID']>;\n};\n\n\n\n\n\n\n/** Ordering options for commit contribution connections. */\nexport type CommitContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field by which to order commit contributions. */\n  field: CommitContributionOrderField;\n};\n\n/** Properties by which commit contribution connections can be ordered. */\nexport enum CommitContributionOrderField {\n  /** Order commit contributions by how many commits they represent. */\n  CommitCount = 'COMMIT_COUNT',\n  /** Order commit contributions by when they were made. */\n  OccurredAt = 'OCCURRED_AT'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/** Varying levels of contributions from none to many. */\nexport enum ContributionLevel {\n  /** Lowest 25% of days of contributions. */\n  FirstQuartile = 'FIRST_QUARTILE',\n  /** Highest 25% of days of contributions. More contributions than the third quartile. */\n  FourthQuartile = 'FOURTH_QUARTILE',\n  /** No contributions occurred. */\n  None = 'NONE',\n  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */\n  SecondQuartile = 'SECOND_QUARTILE',\n  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */\n  ThirdQuartile = 'THIRD_QUARTILE'\n}\n\n/** Ordering options for contribution connections. */\nexport type ContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n};\n\n\n/** Autogenerated input type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssueInput = {\n  /** The body of the newly created issue. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ProjectCard ID to convert. */\n  projectCardId: Scalars['ID'];\n  /** The ID of the repository to create the issue in. */\n  repositoryId: Scalars['ID'];\n  /** The title of the newly created issue. Defaults to the card's note text. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the pull request to convert to draft */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n/** Autogenerated input type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: Maybe<Scalars['Boolean']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: Maybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: Maybe<Scalars['Boolean']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern: Scalars['String'];\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: Maybe<Array<Scalars['ID']>>;\n  /** The global relay id of the repository in which a new branch protection rule should be created in. */\n  repositoryId: Scalars['ID'];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: Maybe<Scalars['Boolean']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: Maybe<Scalars['Boolean']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: Maybe<Scalars['Boolean']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: Maybe<Scalars['Boolean']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;\n};\n\n\n/** Autogenerated input type of CreateCheckRun */\nexport type CreateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: Maybe<Array<CheckRunAction>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The time that the check run finished. */\n  completedAt?: Maybe<Scalars['DateTime']>;\n  /** The final conclusion of the check. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: Maybe<Scalars['URI']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID'];\n  /** The name of the check. */\n  name: Scalars['String'];\n  /** Descriptive details about the run. */\n  output?: Maybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The time that the check run began. */\n  startedAt?: Maybe<Scalars['DateTime']>;\n  /** The current status. */\n  status?: Maybe<RequestableCheckStatusState>;\n};\n\n\n/** Autogenerated input type of CreateCheckSuite */\nexport type CreateCheckSuiteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateContentAttachment */\nexport type CreateContentAttachmentInput = {\n  /** The body of the content attachment, which may contain markdown. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The node ID of the content_reference. */\n  contentReferenceId: Scalars['ID'];\n  /** The title of the content attachment. */\n  title: Scalars['String'];\n};\n\n\n/** Autogenerated input type of CreateDeployment */\nexport type CreateDeploymentInput = {\n  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */\n  autoMerge?: Maybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Short description of the deployment. */\n  description?: Maybe<Scalars['String']>;\n  /** Name for the target deployment environment. */\n  environment?: Maybe<Scalars['String']>;\n  /** JSON payload with extra information about the deployment. */\n  payload?: Maybe<Scalars['String']>;\n  /** The node ID of the ref to be deployed. */\n  refId: Scalars['ID'];\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /**\n   * The status contexts to verify against commit status checks. To bypass required\n   * contexts, pass an empty array. Defaults to all unique contexts.\n   */\n  requiredContexts?: Maybe<Array<Scalars['String']>>;\n  /** Specifies a task to execute. */\n  task?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusInput = {\n  /**\n   * Adds a new inactive status to all non-transient, non-production environment\n   * deployments with the same repository and environment name as the created\n   * status's deployment.\n   */\n  autoInactive?: Maybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The node ID of the deployment. */\n  deploymentId: Scalars['ID'];\n  /** A short description of the status. Maximum length of 140 characters. */\n  description?: Maybe<Scalars['String']>;\n  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */\n  environment?: Maybe<Scalars['String']>;\n  /** Sets the URL for accessing your environment. */\n  environmentUrl?: Maybe<Scalars['String']>;\n  /**\n   * The log URL to associate with this status.       This URL should contain\n   * output to keep the user updated while the task is running       or serve as\n   * historical information for what happened in the deployment.\n   */\n  logUrl?: Maybe<Scalars['String']>;\n  /** The state of the deployment. */\n  state: DeploymentStatusState;\n};\n\n\n/** Autogenerated input type of CreateDiscussion */\nexport type CreateDiscussionInput = {\n  /** The body of the discussion. */\n  body: Scalars['String'];\n  /** The id of the discussion category to associate with this discussion. */\n  categoryId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the repository on which to create the discussion. */\n  repositoryId: Scalars['ID'];\n  /** The title of the discussion. */\n  title: Scalars['String'];\n};\n\n\n/** Autogenerated input type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationInput = {\n  /** The logins for the administrators of the new organization. */\n  adminLogins: Array<Scalars['String']>;\n  /** The email used for sending billing receipts. */\n  billingEmail: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise owning the new organization. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the new organization. */\n  login: Scalars['String'];\n  /** The profile name of the new organization. */\n  profileName: Scalars['String'];\n};\n\n\n/** Autogenerated input type of CreateEnvironment */\nexport type CreateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the environment. */\n  name: Scalars['String'];\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean'];\n  /** An optional name for the IP allow list entry. */\n  name?: Maybe<Scalars['String']>;\n  /** The ID of the owner for which to create the new IP allow list entry. */\n  ownerId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateIssue */\nexport type CreateIssueInput = {\n  /** The Node ID for the user assignee for this issue. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>;\n  /** The body for the issue description. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */\n  issueTemplate?: Maybe<Scalars['String']>;\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: Maybe<Array<Scalars['ID']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: Maybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: Maybe<Array<Scalars['ID']>>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The title for the issue. */\n  title: Scalars['String'];\n};\n\n\n/** Autogenerated input type of CreateLabel */\nexport type CreateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A 6 character hex code, without the leading #, identifying the color of the label. */\n  color: Scalars['String'];\n  /** A brief description of the label, such as its purpose. */\n  description?: Maybe<Scalars['String']>;\n  /** The name of the label. */\n  name: Scalars['String'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateProject */\nexport type CreateProjectInput = {\n  /** The description of project. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of project. */\n  name: Scalars['String'];\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID'];\n  /** A list of repository IDs to create as linked repositories for the project */\n  repositoryIds?: Maybe<Array<Scalars['ID']>>;\n  /** The name of the GitHub-provided template. */\n  template?: Maybe<ProjectTemplate>;\n};\n\n\n/** Autogenerated input type of CreatePullRequest */\nexport type CreatePullRequestInput = {\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository. You cannot update the base branch on a pull request to point\n   * to another repository.\n   */\n  baseRefName: Scalars['String'];\n  /** The contents of the pull request. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Indicates whether this pull request should be a draft. */\n  draft?: Maybe<Scalars['Boolean']>;\n  /**\n   * The name of the branch where your changes are implemented. For cross-repository pull requests\n   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.\n   */\n  headRefName: Scalars['String'];\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: Maybe<Scalars['Boolean']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The title of the pull request. */\n  title: Scalars['String'];\n};\n\n\n/** Autogenerated input type of CreateRef */\nexport type CreateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */\n  name: Scalars['String'];\n  /** The GitObjectID that the new Ref shall target. Must point to a commit. */\n  oid: Scalars['GitObjectID'];\n  /** The Node ID of the Repository to create the Ref in. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateRepository */\nexport type CreateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A short description of the new repository. */\n  description?: Maybe<Scalars['String']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: Maybe<Scalars['Boolean']>;\n  /** The URL for a web page about this repository. */\n  homepageUrl?: Maybe<Scalars['URI']>;\n  /** The name of the new repository. */\n  name: Scalars['String'];\n  /** The ID of the owner for the new repository. */\n  ownerId?: Maybe<Scalars['ID']>;\n  /**\n   * When an organization is specified as the owner, this ID identifies the team\n   * that should be granted access to the new repository.\n   */\n  teamId?: Maybe<Scalars['ID']>;\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: Maybe<Scalars['Boolean']>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n\n/** Autogenerated input type of CreateSponsorship */\nexport type CreateSponsorshipInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: Maybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: Maybe<Scalars['Boolean']>;\n  /** The ID of user or organization who is acting as the sponsor, paying for the sponsorship. */\n  sponsorId: Scalars['ID'];\n  /** The ID of user or organization who is receiving the sponsorship. */\n  sponsorableId: Scalars['ID'];\n  /** The ID of tier to sponsor at. */\n  tierId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentInput = {\n  /** The content of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the discussion to which the comment belongs. */\n  discussionId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionInput = {\n  /** The content of the discussion. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /**\n   * If true, restricts the visibility of this discussion to team members and\n   * organization admins. If false or not specified, allows any organization member\n   * to view this discussion.\n   */\n  private?: Maybe<Scalars['Boolean']>;\n  /** The ID of the team to which the discussion belongs. */\n  teamId: Scalars['ID'];\n  /** The title of the discussion. */\n  title: Scalars['String'];\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Autogenerated input type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String'];\n  /** The reason why the suggested topic is declined. */\n  reason: TopicSuggestionDeclineReason;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** The possible base permissions for repositories. */\nexport enum DefaultRepositoryPermissionField {\n  /** Can read, write, and administrate repos by default */\n  Admin = 'ADMIN',\n  /** No access */\n  None = 'NONE',\n  /** Can read repos by default */\n  Read = 'READ',\n  /** Can read and write repos by default */\n  Write = 'WRITE'\n}\n\n\n/** Autogenerated input type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRuleInput = {\n  /** The global relay id of the branch protection rule to be deleted. */\n  branchProtectionRuleId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of DeleteDeployment */\nexport type DeleteDeploymentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the deployment to be deleted. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node id of the discussion comment to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteDiscussion */\nexport type DeleteDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the discussion to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteEnvironment */\nexport type DeleteEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the environment to be deleted. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the IP allow list entry to delete. */\n  ipAllowListEntryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteIssueComment */\nexport type DeleteIssueCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteIssue */\nexport type DeleteIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the issue to delete. */\n  issueId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteLabel */\nexport type DeleteLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the label to be deleted. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeletePackageVersion */\nexport type DeletePackageVersionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the package version to be deleted. */\n  packageVersionId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteProjectCard */\nexport type DeleteProjectCardInput = {\n  /** The id of the card to delete. */\n  cardId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of DeleteProjectColumn */\nexport type DeleteProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the column to delete. */\n  columnId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteProject */\nexport type DeleteProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeletePullRequestReview */\nexport type DeletePullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the pull request review to delete. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteRef */\nexport type DeleteRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the Ref to be deleted. */\n  refId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion ID to delete. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the verifiable domain to delete. */\n  id: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Ordering options for deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order deployments by. */\n  field: DeploymentOrderField;\n};\n\n/** Properties by which deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  /** Order collection by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n/** The possible protection rule types. */\nexport enum DeploymentProtectionRuleType {\n  /** Required reviewers */\n  RequiredReviewers = 'REQUIRED_REVIEWERS',\n  /** Wait timer */\n  WaitTimer = 'WAIT_TIMER'\n}\n\n\n\n\n\n\n\n/** The possible states for a deployment review. */\nexport enum DeploymentReviewState {\n  /** The deployment was approved. */\n  Approved = 'APPROVED',\n  /** The deployment was rejected. */\n  Rejected = 'REJECTED'\n}\n\n\n\n\n/** The possible states in which a deployment can be. */\nexport enum DeploymentState {\n  /** The pending deployment was not updated after 30 minutes. */\n  Abandoned = 'ABANDONED',\n  /** The deployment is currently active. */\n  Active = 'ACTIVE',\n  /** An inactive transient deployment. */\n  Destroyed = 'DESTROYED',\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment has queued */\n  Queued = 'QUEUED',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n\n\n\n/** The possible states for a deployment status. */\nexport enum DeploymentStatusState {\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment is queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n/** The possible sides of a diff. */\nexport enum DiffSide {\n  /** The left side of the diff. */\n  Left = 'LEFT',\n  /** The right side of the diff. */\n  Right = 'RIGHT'\n}\n\n/** Autogenerated input type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergeInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the pull request to disable auto merge on. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n\n\n\n\n/** Ways in which lists of discussions can be ordered upon return. */\nexport type DiscussionOrder = {\n  /** The direction in which to order discussions by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order discussions. */\n  field: DiscussionOrderField;\n};\n\n/** Properties by which discussion connections can be ordered. */\nexport enum DiscussionOrderField {\n  /** Order discussions by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order discussions by most recent modification time. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Autogenerated input type of DismissPullRequestReview */\nexport type DismissPullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The contents of the pull request review dismissal message. */\n  message: Scalars['String'];\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n\n/** Specifies a review comment to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewComment = {\n  /** Body of the comment to leave. */\n  body: Scalars['String'];\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** Position in the file to leave a comment on. */\n  position: Scalars['Int'];\n};\n\n/** Specifies a review comment thread to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewThread = {\n  /** Body of the comment to leave. */\n  body: Scalars['String'];\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int'];\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: Maybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: Maybe<Scalars['Int']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: Maybe<DiffSide>;\n};\n\n/** Autogenerated input type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergeInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitBody?: Maybe<Scalars['String']>;\n  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitHeadline?: Maybe<Scalars['String']>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: Maybe<PullRequestMergeMethod>;\n  /** ID of the pull request to enable auto-merge on. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n/** Ordering options for enterprise administrator invitation connections */\nexport type EnterpriseAdministratorInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise administrator invitations by. */\n  field: EnterpriseAdministratorInvitationOrderField;\n};\n\n/** Properties by which enterprise administrator invitation connections can be ordered. */\nexport enum EnterpriseAdministratorInvitationOrderField {\n  /** Order enterprise administrator member invitations by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible administrator roles in an enterprise account. */\nexport enum EnterpriseAdministratorRole {\n  /** Represents a billing manager of the enterprise account. */\n  BillingManager = 'BILLING_MANAGER',\n  /** Represents an owner of the enterprise account. */\n  Owner = 'OWNER'\n}\n\n\n\n/** The possible values for the enterprise base repository permission setting. */\nexport enum EnterpriseDefaultRepositoryPermissionSettingValue {\n  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */\n  Admin = 'ADMIN',\n  /** Organization members will only be able to clone and pull public repositories. */\n  None = 'NONE',\n  /** Organizations in the enterprise choose base repository permissions for their members. */\n  NoPolicy = 'NO_POLICY',\n  /** Organization members will be able to clone and pull all organization repositories. */\n  Read = 'READ',\n  /** Organization members will be able to clone, pull, and push all organization repositories. */\n  Write = 'WRITE'\n}\n\n/** The possible values for an enabled/disabled enterprise setting. */\nexport enum EnterpriseEnabledDisabledSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n/** The possible values for an enabled/no policy enterprise setting. */\nexport enum EnterpriseEnabledSettingValue {\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n\n\n\n\n/** Ordering options for enterprise member connections. */\nexport type EnterpriseMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise members by. */\n  field: EnterpriseMemberOrderField;\n};\n\n/** Properties by which enterprise member connections can be ordered. */\nexport enum EnterpriseMemberOrderField {\n  /** Order enterprise members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order enterprise members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible values for the enterprise members can create repositories setting. */\nexport enum EnterpriseMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Organization administrators choose whether to allow members to create repositories. */\n  NoPolicy = 'NO_POLICY',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE',\n  /** Members will be able to create only public repositories. */\n  Public = 'PUBLIC'\n}\n\n/** The possible values for the members can make purchases setting. */\nexport enum EnterpriseMembersCanMakePurchasesSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Ordering options for Enterprise Server installation connections. */\nexport type EnterpriseServerInstallationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order Enterprise Server installations by. */\n  field: EnterpriseServerInstallationOrderField;\n};\n\n/** Properties by which Enterprise Server installation connections can be ordered. */\nexport enum EnterpriseServerInstallationOrderField {\n  /** Order Enterprise Server installations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order Enterprise Server installations by customer name */\n  CustomerName = 'CUSTOMER_NAME',\n  /** Order Enterprise Server installations by host name */\n  HostName = 'HOST_NAME'\n}\n\n\n\n\n\n\n\n/** Ordering options for Enterprise Server user account email connections. */\nexport type EnterpriseServerUserAccountEmailOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order emails by. */\n  field: EnterpriseServerUserAccountEmailOrderField;\n};\n\n/** Properties by which Enterprise Server user account email connections can be ordered. */\nexport enum EnterpriseServerUserAccountEmailOrderField {\n  /** Order emails by email */\n  Email = 'EMAIL'\n}\n\n/** Ordering options for Enterprise Server user account connections. */\nexport type EnterpriseServerUserAccountOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts by. */\n  field: EnterpriseServerUserAccountOrderField;\n};\n\n/** Properties by which Enterprise Server user account connections can be ordered. */\nexport enum EnterpriseServerUserAccountOrderField {\n  /** Order user accounts by login */\n  Login = 'LOGIN',\n  /** Order user accounts by creation time on the Enterprise Server installation */\n  RemoteCreatedAt = 'REMOTE_CREATED_AT'\n}\n\n\n\n\n/** Ordering options for Enterprise Server user accounts upload connections. */\nexport type EnterpriseServerUserAccountsUploadOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts uploads by. */\n  field: EnterpriseServerUserAccountsUploadOrderField;\n};\n\n/** Properties by which Enterprise Server user accounts upload connections can be ordered. */\nexport enum EnterpriseServerUserAccountsUploadOrderField {\n  /** Order user accounts uploads by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Synchronization state of the Enterprise Server user accounts upload */\nexport enum EnterpriseServerUserAccountsUploadSyncState {\n  /** The synchronization of the upload failed. */\n  Failure = 'FAILURE',\n  /** The synchronization of the upload is pending. */\n  Pending = 'PENDING',\n  /** The synchronization of the upload succeeded. */\n  Success = 'SUCCESS'\n}\n\n\n\n\n/** The possible roles for enterprise membership. */\nexport enum EnterpriseUserAccountMembershipRole {\n  /** The user is a member of the enterprise membership. */\n  Member = 'MEMBER',\n  /** The user is an owner of the enterprise membership. */\n  Owner = 'OWNER'\n}\n\n/** The possible GitHub Enterprise deployments where this user can exist. */\nexport enum EnterpriseUserDeployment {\n  /** The user is part of a GitHub Enterprise Cloud deployment. */\n  Cloud = 'CLOUD',\n  /** The user is part of a GitHub Enterprise Server deployment. */\n  Server = 'SERVER'\n}\n\n\n\n\n\n\n\n\n\n/** The possible viewed states of a file . */\nexport enum FileViewedState {\n  /** The file has new changes since last viewed. */\n  Dismissed = 'DISMISSED',\n  /** The file has not been marked as viewed. */\n  Unviewed = 'UNVIEWED',\n  /** The file has been marked as viewed. */\n  Viewed = 'VIEWED'\n}\n\n/** Autogenerated input type of FollowUser */\nexport type FollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the user to follow. */\n  userId: Scalars['ID'];\n};\n\n\n\n\n\n/** The possible funding platforms for repository funding links. */\nexport enum FundingPlatform {\n  /** Community Bridge funding platform. */\n  CommunityBridge = 'COMMUNITY_BRIDGE',\n  /** Custom funding platform. */\n  Custom = 'CUSTOM',\n  /** GitHub funding platform. */\n  Github = 'GITHUB',\n  /** IssueHunt funding platform. */\n  Issuehunt = 'ISSUEHUNT',\n  /** Ko-fi funding platform. */\n  KoFi = 'KO_FI',\n  /** Liberapay funding platform. */\n  Liberapay = 'LIBERAPAY',\n  /** Open Collective funding platform. */\n  OpenCollective = 'OPEN_COLLECTIVE',\n  /** Otechie funding platform. */\n  Otechie = 'OTECHIE',\n  /** Patreon funding platform. */\n  Patreon = 'PATREON',\n  /** Tidelift funding platform. */\n  Tidelift = 'TIDELIFT'\n}\n\n\n\n\n\n\n\n\n\n/** Ordering options for gist connections */\nexport type GistOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: GistOrderField;\n};\n\n/** Properties by which gist connections can be ordered. */\nexport enum GistOrderField {\n  /** Order gists by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order gists by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order gists by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The privacy of a Gist */\nexport enum GistPrivacy {\n  /** Gists that are public and secret */\n  All = 'ALL',\n  /** Public */\n  Public = 'PUBLIC',\n  /** Secret */\n  Secret = 'SECRET'\n}\n\n\n\n\n\n\n\n\n\n\n/** The state of a Git signature. */\nexport enum GitSignatureState {\n  /** The signing certificate or its chain could not be verified */\n  BadCert = 'BAD_CERT',\n  /** Invalid email used for signing */\n  BadEmail = 'BAD_EMAIL',\n  /** Signing key expired */\n  ExpiredKey = 'EXPIRED_KEY',\n  /** Internal error - the GPG verification service misbehaved */\n  GpgverifyError = 'GPGVERIFY_ERROR',\n  /** Internal error - the GPG verification service is unavailable at the moment */\n  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',\n  /** Invalid signature */\n  Invalid = 'INVALID',\n  /** Malformed signature */\n  MalformedSig = 'MALFORMED_SIG',\n  /** The usage flags for the key that signed this don't allow signing */\n  NotSigningKey = 'NOT_SIGNING_KEY',\n  /** Email used for signing not known to GitHub */\n  NoUser = 'NO_USER',\n  /** Valid signature, though certificate revocation check failed */\n  OcspError = 'OCSP_ERROR',\n  /** Valid signature, pending certificate revocation checking */\n  OcspPending = 'OCSP_PENDING',\n  /** One or more certificates in chain has been revoked */\n  OcspRevoked = 'OCSP_REVOKED',\n  /** Key used for signing not known to GitHub */\n  UnknownKey = 'UNKNOWN_KEY',\n  /** Unknown signature type */\n  UnknownSigType = 'UNKNOWN_SIG_TYPE',\n  /** Unsigned */\n  Unsigned = 'UNSIGNED',\n  /** Email used for signing unverified on GitHub */\n  UnverifiedEmail = 'UNVERIFIED_EMAIL',\n  /** Valid signature and verified by GitHub */\n  Valid = 'VALID'\n}\n\n\n\n\n\n\n\n\n\n/** The possible states in which authentication can be configured with an identity provider. */\nexport enum IdentityProviderConfigurationState {\n  /** Authentication with an identity provider is configured but not enforced. */\n  Configured = 'CONFIGURED',\n  /** Authentication with an identity provider is configured and enforced. */\n  Enforced = 'ENFORCED',\n  /** Authentication with an identity provider is not configured. */\n  Unconfigured = 'UNCONFIGURED'\n}\n\n/** Autogenerated input type of ImportProject */\nexport type ImportProjectInput = {\n  /** The description of Project. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A list of columns containing issues and pull requests. */\n  columnImports: Array<ProjectColumnImport>;\n  /** The name of Project. */\n  name: Scalars['String'];\n  /** The name of the Organization or User to create the Project under. */\n  ownerName: Scalars['String'];\n  /** Whether the Project is public or not. */\n  public?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Autogenerated input type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The email of the person to invite as an administrator. */\n  email?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise to which you want to invite an administrator. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a user to invite as an administrator. */\n  invitee?: Maybe<Scalars['String']>;\n  /** The role of the administrator. */\n  role?: Maybe<EnterpriseAdministratorRole>;\n};\n\n\n/** The possible values for the IP allow list enabled setting. */\nexport enum IpAllowListEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n\n\n\n/** Ordering options for IP allow list entry connections. */\nexport type IpAllowListEntryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order IP allow list entries by. */\n  field: IpAllowListEntryOrderField;\n};\n\n/** Properties by which IP allow list entry connections can be ordered. */\nexport enum IpAllowListEntryOrderField {\n  /** Order IP allow list entries by the allow list value. */\n  AllowListValue = 'ALLOW_LIST_VALUE',\n  /** Order IP allow list entries by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */\nexport enum IpAllowListForInstalledAppsEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n\n\n\n\n\n/** Ways in which lists of issue comments can be ordered upon return. */\nexport type IssueCommentOrder = {\n  /** The direction in which to order issue comments by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issue comments by. */\n  field: IssueCommentOrderField;\n};\n\n/** Properties by which issue comment connections can be ordered. */\nexport enum IssueCommentOrderField {\n  /** Order issue comments by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n\n/** Ways in which to filter lists of issues. */\nexport type IssueFilters = {\n  /**\n   * List issues assigned to given name. Pass in `null` for issues with no assigned\n   * user, and `*` for issues assigned to any user.\n   */\n  assignee?: Maybe<Scalars['String']>;\n  /** List issues created by given name. */\n  createdBy?: Maybe<Scalars['String']>;\n  /** List issues where the list of label names exist on the issue. */\n  labels?: Maybe<Array<Scalars['String']>>;\n  /** List issues where the given name is mentioned in the issue. */\n  mentioned?: Maybe<Scalars['String']>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its number field. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestone?: Maybe<Scalars['String']>;\n  /** List issues that have been updated at or after the given date. */\n  since?: Maybe<Scalars['DateTime']>;\n  /** List issues filtered by the list of states given. */\n  states?: Maybe<Array<IssueState>>;\n  /** List issues subscribed to by viewer. */\n  viewerSubscribed?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type IssueOrder = {\n  /** The direction in which to order issues by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issues by. */\n  field: IssueOrderField;\n};\n\n/** Properties by which issue connections can be ordered. */\nexport enum IssueOrderField {\n  /** Order issues by comment count */\n  Comments = 'COMMENTS',\n  /** Order issues by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order issues by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of an issue. */\nexport enum IssueState {\n  /** An issue that has been closed */\n  Closed = 'CLOSED',\n  /** An issue that is still open */\n  Open = 'OPEN'\n}\n\n\n\n\n\n\n\n\n/** The possible item types found in a timeline. */\nexport enum IssueTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n\n\n\n\n/** Ways in which lists of labels can be ordered upon return. */\nexport type LabelOrder = {\n  /** The direction in which to order labels by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order labels by. */\n  field: LabelOrderField;\n};\n\n/** Properties by which label connections can be ordered. */\nexport enum LabelOrderField {\n  /** Order labels by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order labels by name */\n  Name = 'NAME'\n}\n\n\n\n\n\n\n/** Ordering options for language connections. */\nexport type LanguageOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order languages by. */\n  field: LanguageOrderField;\n};\n\n/** Properties by which language connections can be ordered. */\nexport enum LanguageOrderField {\n  /** Order languages by the size of all files containing the language */\n  Size = 'SIZE'\n}\n\n\n\n/** Autogenerated input type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Project to link to a Repository */\n  projectId: Scalars['ID'];\n  /** The ID of the Repository to link to a Project. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of LockLockable */\nexport type LockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A reason for why the item will be locked. */\n  lockReason?: Maybe<LockReason>;\n  /** ID of the item to be locked. */\n  lockableId: Scalars['ID'];\n};\n\n\n/** The possible reasons that an issue or pull request was locked. */\nexport enum LockReason {\n  /** The issue or pull request was locked because the conversation was off-topic. */\n  OffTopic = 'OFF_TOPIC',\n  /** The issue or pull request was locked because the conversation was resolved. */\n  Resolved = 'RESOLVED',\n  /** The issue or pull request was locked because the conversation was spam. */\n  Spam = 'SPAM',\n  /** The issue or pull request was locked because the conversation was too heated. */\n  TooHeated = 'TOO_HEATED'\n}\n\n\n\n\n/** Autogenerated input type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to mark as an answer. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of MarkFileAsViewed */\nexport type MarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The path of the file to mark as viewed */\n  path: Scalars['String'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the pull request to be marked as ready for review. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n\n\n\n\n/** Autogenerated input type of MergeBranch */\nexport type MergeBranchInput = {\n  /** The email address to associate with this commit. */\n  authorEmail?: Maybe<Scalars['String']>;\n  /** The name of the base branch that the provided head will be merged into. */\n  base: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Message to use for the merge commit. If omitted, a default will be used. */\n  commitMessage?: Maybe<Scalars['String']>;\n  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */\n  head: Scalars['String'];\n  /** The Node ID of the Repository containing the base branch that will be modified. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of MergePullRequest */\nexport type MergePullRequestInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Commit body to use for the merge commit; if omitted, a default message will be used */\n  commitBody?: Maybe<Scalars['String']>;\n  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */\n  commitHeadline?: Maybe<Scalars['String']>;\n  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */\n  expectedHeadOid?: Maybe<Scalars['GitObjectID']>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: Maybe<PullRequestMergeMethod>;\n  /** ID of the pull request to be merged. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n/** Detailed status information about a pull request merge. */\nexport enum MergeStateStatus {\n  /** The head ref is out of date. */\n  Behind = 'BEHIND',\n  /** The merge is blocked. */\n  Blocked = 'BLOCKED',\n  /** Mergeable and passing commit status. */\n  Clean = 'CLEAN',\n  /** The merge commit cannot be cleanly created. */\n  Dirty = 'DIRTY',\n  /** The merge is blocked due to the pull request being a draft. */\n  Draft = 'DRAFT',\n  /** Mergeable with passing commit status and pre-receive hooks. */\n  HasHooks = 'HAS_HOOKS',\n  /** The state cannot currently be determined. */\n  Unknown = 'UNKNOWN',\n  /** Mergeable with non-passing commit status. */\n  Unstable = 'UNSTABLE'\n}\n\n/** Whether or not a PullRequest can be merged. */\nexport enum MergeableState {\n  /** The pull request cannot be merged due to merge conflicts. */\n  Conflicting = 'CONFLICTING',\n  /** The pull request can be merged. */\n  Mergeable = 'MERGEABLE',\n  /** The mergeability of the pull request is still being calculated. */\n  Unknown = 'UNKNOWN'\n}\n\n\n\n\n\n\n/** Ordering options for milestone connections. */\nexport type MilestoneOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order milestones by. */\n  field: MilestoneOrderField;\n};\n\n/** Properties by which milestone connections can be ordered. */\nexport enum MilestoneOrderField {\n  /** Order milestones by when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order milestones by when they are due. */\n  DueDate = 'DUE_DATE',\n  /** Order milestones by their number. */\n  Number = 'NUMBER',\n  /** Order milestones by when they were last updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of a milestone. */\nexport enum MilestoneState {\n  /** A milestone that has been closed. */\n  Closed = 'CLOSED',\n  /** A milestone that is still open. */\n  Open = 'OPEN'\n}\n\n\n\n/** Autogenerated input type of MinimizeComment */\nexport type MinimizeCommentInput = {\n  /** The classification of comment */\n  classifier: ReportedContentClassifiers;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of MoveProjectCard */\nexport type MoveProjectCardInput = {\n  /** Place the new card after the card with this id. Pass null to place it at the top. */\n  afterCardId?: Maybe<Scalars['ID']>;\n  /** The id of the card to move. */\n  cardId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the column to move it into. */\n  columnId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of MoveProjectColumn */\nexport type MoveProjectColumnInput = {\n  /** Place the new column after the column with this id. Pass null to place it at the front. */\n  afterColumnId?: Maybe<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the column to move. */\n  columnId: Scalars['ID'];\n};\n\n\n\n\n\n/** The possible values for the notification restriction setting. */\nexport enum NotificationRestrictionSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n\n\n/** The state of an OAuth Application when it was created. */\nexport enum OauthApplicationCreateAuditEntryState {\n  /** The OAuth Application was active and allowed to have OAuth Accesses. */\n  Active = 'ACTIVE',\n  /** The OAuth Application was in the process of being deleted. */\n  PendingDeletion = 'PENDING_DELETION',\n  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */\n  Suspended = 'SUSPENDED'\n}\n\n/** The corresponding operation type for the action */\nexport enum OperationType {\n  /** An existing resource was accessed */\n  Access = 'ACCESS',\n  /** A resource performed an authentication event */\n  Authentication = 'AUTHENTICATION',\n  /** A new resource was created */\n  Create = 'CREATE',\n  /** An existing resource was modified */\n  Modify = 'MODIFY',\n  /** An existing resource was removed */\n  Remove = 'REMOVE',\n  /** An existing resource was restored */\n  Restore = 'RESTORE',\n  /** An existing resource was transferred between multiple resources */\n  Transfer = 'TRANSFER'\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\n\n\n/** The permissions available to members on an Organization. */\nexport enum OrgAddMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n\n\n\n\n/** The billing plans available for organizations. */\nexport enum OrgCreateAuditEntryBillingPlan {\n  /** Team Plan */\n  Business = 'BUSINESS',\n  /** Enterprise Cloud Plan */\n  BusinessPlus = 'BUSINESS_PLUS',\n  /** Free Plan */\n  Free = 'FREE',\n  /** Tiered Per Seat Plan */\n  TieredPerSeat = 'TIERED_PER_SEAT',\n  /** Legacy Unlimited Plan */\n  Unlimited = 'UNLIMITED'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** The reason a billing manager was removed from an Organization. */\nexport enum OrgRemoveBillingManagerAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveMemberAuditEntryMembershipType {\n  /**\n   * Organization administrators have full access and can change several settings,\n   * including the names of repositories that belong to the Organization and Owners\n   * team membership. In addition, organization admins can delete the organization\n   * and all of its repositories.\n   */\n  Admin = 'ADMIN',\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /** A direct member is a user that is a member of the Organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the Organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason a member was removed from an Organization. */\nexport enum OrgRemoveMemberAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** User was removed from organization during account recovery */\n  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n  /** User account has been deleted */\n  UserAccountDeleted = 'USER_ACCOUNT_DELETED'\n}\n\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason an outside collaborator was removed from an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n\n\n\n\n\n\n\n/** The default permission a repository can have in an Organization. */\nexport enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** No default permission value. */\n  None = 'NONE',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n  /** Can read, clone and push to repositories. */\n  Write = 'WRITE'\n}\n\n\n/** The permissions available to members on an Organization. */\nexport enum OrgUpdateMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n\n/** The permissions available for repository creation on an Organization. */\nexport enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {\n  /** All organization members are restricted from creating any repositories. */\n  All = 'ALL',\n  /** All organization members are restricted from creating internal repositories. */\n  Internal = 'INTERNAL',\n  /** All organization members are allowed to create any repositories. */\n  None = 'NONE',\n  /** All organization members are restricted from creating private repositories. */\n  Private = 'PRIVATE',\n  /** All organization members are restricted from creating private or internal repositories. */\n  PrivateInternal = 'PRIVATE_INTERNAL',\n  /** All organization members are restricted from creating public repositories. */\n  Public = 'PUBLIC',\n  /** All organization members are restricted from creating public or internal repositories. */\n  PublicInternal = 'PUBLIC_INTERNAL',\n  /** All organization members are restricted from creating public or private repositories. */\n  PublicPrivate = 'PUBLIC_PRIVATE'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** The possible organization invitation roles. */\nexport enum OrganizationInvitationRole {\n  /** The user is invited to be an admin of the organization. */\n  Admin = 'ADMIN',\n  /** The user is invited to be a billing manager of the organization. */\n  BillingManager = 'BILLING_MANAGER',\n  /** The user is invited to be a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** The user's previous role will be reinstated. */\n  Reinstate = 'REINSTATE'\n}\n\n/** The possible organization invitation types. */\nexport enum OrganizationInvitationType {\n  /** The invitation was to an email address. */\n  Email = 'EMAIL',\n  /** The invitation was to an existing user. */\n  User = 'USER'\n}\n\n\n\n/** The possible roles within an organization for its members. */\nexport enum OrganizationMemberRole {\n  /** The user is an administrator of the organization. */\n  Admin = 'ADMIN',\n  /** The user is a member of the organization. */\n  Member = 'MEMBER'\n}\n\n/** The possible values for the members can create repositories setting on an organization. */\nexport enum OrganizationMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Members will be able to create only internal repositories. */\n  Internal = 'INTERNAL',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE'\n}\n\n/** Ordering options for organization connections. */\nexport type OrganizationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order organizations by. */\n  field: OrganizationOrderField;\n};\n\n/** Properties by which organization connections can be ordered. */\nexport enum OrganizationOrderField {\n  /** Order organizations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order organizations by login */\n  Login = 'LOGIN'\n}\n\n\n\n\n\n\n\n\n\n/** Ways in which lists of package files can be ordered upon return. */\nexport type PackageFileOrder = {\n  /** The direction in which to order package files by the specified field. */\n  direction?: Maybe<OrderDirection>;\n  /** The field in which to order package files by. */\n  field?: Maybe<PackageFileOrderField>;\n};\n\n/** Properties by which package file connections can be ordered. */\nexport enum PackageFileOrderField {\n  /** Order package files by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ways in which lists of packages can be ordered upon return. */\nexport type PackageOrder = {\n  /** The direction in which to order packages by the specified field. */\n  direction?: Maybe<OrderDirection>;\n  /** The field in which to order packages by. */\n  field?: Maybe<PackageOrderField>;\n};\n\n/** Properties by which package connections can be ordered. */\nexport enum PackageOrderField {\n  /** Order packages by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n/** The possible types of a package. */\nexport enum PackageType {\n  /** A debian package. */\n  Debian = 'DEBIAN',\n  /** A docker image. */\n  Docker = 'DOCKER',\n  /** A maven package. */\n  Maven = 'MAVEN',\n  /** An npm package. */\n  Npm = 'NPM',\n  /** A nuget package. */\n  Nuget = 'NUGET',\n  /** A python package. */\n  Pypi = 'PYPI',\n  /** A rubygems package. */\n  Rubygems = 'RUBYGEMS'\n}\n\n\n\n\n/** Ways in which lists of package versions can be ordered upon return. */\nexport type PackageVersionOrder = {\n  /** The direction in which to order package versions by the specified field. */\n  direction?: Maybe<OrderDirection>;\n  /** The field in which to order package versions by. */\n  field?: Maybe<PackageVersionOrderField>;\n};\n\n/** Properties by which package version connections can be ordered. */\nexport enum PackageVersionOrderField {\n  /** Order package versions by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n\n/** Autogenerated input type of PinIssue */\nexport type PinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the issue to be pinned */\n  issueId: Scalars['ID'];\n};\n\n\n\n\n\n/** Represents items that can be pinned to a profile page or dashboard. */\nexport enum PinnableItemType {\n  /** A gist. */\n  Gist = 'GIST',\n  /** An issue. */\n  Issue = 'ISSUE',\n  /** An organization. */\n  Organization = 'ORGANIZATION',\n  /** A project. */\n  Project = 'PROJECT',\n  /** A pull request. */\n  PullRequest = 'PULL_REQUEST',\n  /** A repository. */\n  Repository = 'REPOSITORY',\n  /** A team. */\n  Team = 'TEAM',\n  /** A user. */\n  User = 'USER'\n}\n\n\n\n\n/** Preconfigured gradients that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionGradient {\n  /** A gradient of blue to mint */\n  BlueMint = 'BLUE_MINT',\n  /** A gradient of blue to purple */\n  BluePurple = 'BLUE_PURPLE',\n  /** A gradient of pink to blue */\n  PinkBlue = 'PINK_BLUE',\n  /** A gradient of purple to coral */\n  PurpleCoral = 'PURPLE_CORAL',\n  /** A gradient of red to orange */\n  RedOrange = 'RED_ORANGE'\n}\n\n/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionPattern {\n  /** An upward-facing chevron pattern */\n  ChevronUp = 'CHEVRON_UP',\n  /** A hollow dot pattern */\n  Dot = 'DOT',\n  /** A solid dot pattern */\n  DotFill = 'DOT_FILL',\n  /** A heart pattern */\n  HeartFill = 'HEART_FILL',\n  /** A plus sign pattern */\n  Plus = 'PLUS',\n  /** A lightning bolt pattern */\n  Zap = 'ZAP'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/** The possible archived states of a project card. */\nexport enum ProjectCardArchivedState {\n  /** A project card that is archived */\n  Archived = 'ARCHIVED',\n  /** A project card that is not archived */\n  NotArchived = 'NOT_ARCHIVED'\n}\n\n\n\n/** An issue or PR and its owning repository to be used in a project card. */\nexport type ProjectCardImport = {\n  /** The issue or pull request number. */\n  number: Scalars['Int'];\n  /** Repository name with owner (owner/repository). */\n  repository: Scalars['String'];\n};\n\n\n/** Various content states of a ProjectCard */\nexport enum ProjectCardState {\n  /** The card has content only. */\n  ContentOnly = 'CONTENT_ONLY',\n  /** The card has a note only. */\n  NoteOnly = 'NOTE_ONLY',\n  /** The card is redacted. */\n  Redacted = 'REDACTED'\n}\n\n\n\n\n/** A project column and a list of its issues and PRs. */\nexport type ProjectColumnImport = {\n  /** The name of the column. */\n  columnName: Scalars['String'];\n  /** A list of issues and pull requests in the column. */\n  issues?: Maybe<Array<ProjectCardImport>>;\n  /** The position of the column, starting from 0. */\n  position: Scalars['Int'];\n};\n\n/** The semantic purpose of the column - todo, in progress, or done. */\nexport enum ProjectColumnPurpose {\n  /** The column contains cards which are complete */\n  Done = 'DONE',\n  /** The column contains cards which are currently being worked on */\n  InProgress = 'IN_PROGRESS',\n  /** The column contains cards still to be worked on */\n  Todo = 'TODO'\n}\n\n\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectOrder = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectOrderField;\n};\n\n/** Properties by which project connections can be ordered. */\nexport enum ProjectOrderField {\n  /** Order projects by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order projects by name */\n  Name = 'NAME',\n  /** Order projects by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n/** State of the project; either 'open' or 'closed' */\nexport enum ProjectState {\n  /** The project is closed. */\n  Closed = 'CLOSED',\n  /** The project is open. */\n  Open = 'OPEN'\n}\n\n/** GitHub-provided templates for Projects */\nexport enum ProjectTemplate {\n  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */\n  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',\n  /** Create a board with triggers to automatically move cards across columns with review automation. */\n  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',\n  /** Create a board with columns for To do, In progress and Done. */\n  BasicKanban = 'BASIC_KANBAN',\n  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */\n  BugTriage = 'BUG_TRIAGE'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Represents available types of methods to use when merging a pull request. */\nexport enum PullRequestMergeMethod {\n  /** Add all commits from the head branch to the base branch with a merge commit. */\n  Merge = 'MERGE',\n  /** Add all commits from the head branch onto the base branch individually. */\n  Rebase = 'REBASE',\n  /** Combine all commits from the head branch into a single commit in the base branch. */\n  Squash = 'SQUASH'\n}\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type PullRequestOrder = {\n  /** The direction in which to order pull requests by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order pull requests by. */\n  field: PullRequestOrderField;\n};\n\n/** Properties by which pull_requests connections can be ordered. */\nexport enum PullRequestOrderField {\n  /** Order pull_requests by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order pull_requests by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n\n\n/** The possible states of a pull request review comment. */\nexport enum PullRequestReviewCommentState {\n  /** A comment that is part of a pending review */\n  Pending = 'PENDING',\n  /** A comment that is part of a submitted review */\n  Submitted = 'SUBMITTED'\n}\n\n\n\n/** The review status of a pull request. */\nexport enum PullRequestReviewDecision {\n  /** The pull request has received an approving review. */\n  Approved = 'APPROVED',\n  /** Changes have been requested on the pull request. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** A review is required before the pull request can be merged. */\n  ReviewRequired = 'REVIEW_REQUIRED'\n}\n\n\n/** The possible events to perform on a pull request review. */\nexport enum PullRequestReviewEvent {\n  /** Submit feedback and approve merging these changes. */\n  Approve = 'APPROVE',\n  /** Submit general feedback without explicit approval. */\n  Comment = 'COMMENT',\n  /** Dismiss review so it now longer effects merging. */\n  Dismiss = 'DISMISS',\n  /** Submit feedback that must be addressed before merging. */\n  RequestChanges = 'REQUEST_CHANGES'\n}\n\n/** The possible states of a pull request review. */\nexport enum PullRequestReviewState {\n  /** A review allowing the pull request to merge. */\n  Approved = 'APPROVED',\n  /** A review blocking the pull request from merging. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** An informational review. */\n  Commented = 'COMMENTED',\n  /** A review that has been dismissed. */\n  Dismissed = 'DISMISSED',\n  /** A review that has not yet been submitted. */\n  Pending = 'PENDING'\n}\n\n\n\n\n\n/** The possible states of a pull request. */\nexport enum PullRequestState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that has been closed by being merged. */\n  Merged = 'MERGED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n\n\n\n\n\n\n\n/** The possible item types found in a timeline. */\nexport enum PullRequestTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'automatic_base_change_failed' event on a given pull request. */\n  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',\n  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\n  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',\n  /** Represents a 'auto_merge_disabled' event on a given pull request. */\n  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',\n  /** Represents a 'auto_merge_enabled' event on a given pull request. */\n  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',\n  /** Represents a 'auto_rebase_enabled' event on a given pull request. */\n  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',\n  /** Represents a 'auto_squash_enabled' event on a given pull request. */\n  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',\n  /** Represents a 'base_ref_changed' event on a given issue or pull request. */\n  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',\n  /** Represents a 'base_ref_deleted' event on a given pull request. */\n  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',\n  /** Represents a 'base_ref_force_pushed' event on a given pull request. */\n  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'convert_to_draft' event on a given pull request. */\n  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'deployed' event on a given pull request. */\n  DeployedEvent = 'DEPLOYED_EVENT',\n  /** Represents a 'deployment_environment_changed' event on a given pull request. */\n  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a 'head_ref_deleted' event on a given pull request. */\n  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',\n  /** Represents a 'head_ref_force_pushed' event on a given pull request. */\n  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'head_ref_restored' event on a given pull request. */\n  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'merged' event on a given pull request. */\n  MergedEvent = 'MERGED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a Git commit part of a pull request. */\n  PullRequestCommit = 'PULL_REQUEST_COMMIT',\n  /** Represents a commit comment thread part of a pull request. */\n  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',\n  /** A review object for a given pull request. */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** A threaded list of comments for a given pull request. */\n  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',\n  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\n  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',\n  /** Represents a 'ready_for_review' event on a given pull request. */\n  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'review_dismissed' event on a given issue or pull request. */\n  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',\n  /** Represents an 'review_requested' event on a given pull request. */\n  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',\n  /** Represents an 'review_request_removed' event on a given pull request. */\n  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n/** The possible target states when updating a pull request. */\nexport enum PullRequestUpdateState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Emojis that can be attached to Issues, Pull Requests and Comments. */\nexport enum ReactionContent {\n  /** Represents the `:confused:` emoji. */\n  Confused = 'CONFUSED',\n  /** Represents the `:eyes:` emoji. */\n  Eyes = 'EYES',\n  /** Represents the `:heart:` emoji. */\n  Heart = 'HEART',\n  /** Represents the `:hooray:` emoji. */\n  Hooray = 'HOORAY',\n  /** Represents the `:laugh:` emoji. */\n  Laugh = 'LAUGH',\n  /** Represents the `:rocket:` emoji. */\n  Rocket = 'ROCKET',\n  /** Represents the `:-1:` emoji. */\n  ThumbsDown = 'THUMBS_DOWN',\n  /** Represents the `:+1:` emoji. */\n  ThumbsUp = 'THUMBS_UP'\n}\n\n\n\n/** Ways in which lists of reactions can be ordered upon return. */\nexport type ReactionOrder = {\n  /** The direction in which to order reactions by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order reactions by. */\n  field: ReactionOrderField;\n};\n\n/** A list of fields that reactions can be ordered by. */\nexport enum ReactionOrderField {\n  /** Allows ordering a list of reactions by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n\n\n\n\n/** Ways in which lists of git refs can be ordered upon return. */\nexport type RefOrder = {\n  /** The direction in which to order refs by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order refs by. */\n  field: RefOrderField;\n};\n\n/** Properties by which ref connections can be ordered. */\nexport enum RefOrderField {\n  /** Order refs by their alphanumeric name */\n  Alphabetical = 'ALPHABETICAL',\n  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */\n  TagCommitDate = 'TAG_COMMIT_DATE'\n}\n\n/** A ref update */\nexport type RefUpdate = {\n  /** The value this ref should be updated to. */\n  afterOid: Scalars['GitObjectID'];\n  /** The value this ref needs to point to before the update. */\n  beforeOid?: Maybe<Scalars['GitObjectID']>;\n  /** Force a non fast-forward update. */\n  force?: Maybe<Scalars['Boolean']>;\n  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */\n  name: Scalars['GitRefname'];\n};\n\n\n\n\n/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the verifiable domain to regenerate the verification token of. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RejectDeployments */\nexport type RejectDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Optional comment for rejecting deployments */\n  comment?: Maybe<Scalars['String']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n/** Ways in which lists of releases can be ordered upon return. */\nexport type ReleaseOrder = {\n  /** The direction in which to order releases by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order releases by. */\n  field: ReleaseOrderField;\n};\n\n/** Properties by which release connections can be ordered. */\nexport enum ReleaseOrderField {\n  /** Order releases by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order releases alphabetically by name */\n  Name = 'NAME'\n}\n\n/** Autogenerated input type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignableInput = {\n  /** The id of the assignable object to remove assignees from. */\n  assignableId: Scalars['ID'];\n  /** The id of users to remove as assignees. */\n  assigneeIds: Array<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Enterprise ID from which to remove the administrator. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the user to remove as an administrator. */\n  login: Scalars['String'];\n};\n\n\n/** Autogenerated input type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise from which to remove the identity provider. */\n  enterpriseId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise from which the organization should be removed. */\n  enterpriseId: Scalars['ID'];\n  /** The ID of the organization to remove from the enterprise. */\n  organizationId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a member who will lose the support entitlement. */\n  login: Scalars['String'];\n};\n\n\n/** Autogenerated input type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ids of labels to remove. */\n  labelIds: Array<Scalars['ID']>;\n  /** The id of the Labelable to remove labels from. */\n  labelableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the organization to remove the outside collaborator from. */\n  organizationId: Scalars['ID'];\n  /** The ID of the outside collaborator to remove. */\n  userId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveReaction */\nexport type RemoveReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of the emoji reaction to remove. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveStar */\nexport type RemoveStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Starrable ID to unstar. */\n  starrableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of RemoveUpvote */\nexport type RemoveUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion or comment to remove upvote. */\n  subjectId: Scalars['ID'];\n};\n\n\n\n\n\n/** Autogenerated input type of ReopenIssue */\nexport type ReopenIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the issue to be opened. */\n  issueId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ReopenPullRequest */\nexport type ReopenPullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the pull request to be reopened. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n\n\n/** The privacy of a repository */\nexport enum RepoAccessAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n/** The privacy of a repository */\nexport enum RepoAddMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n\n/** The privacy of a repository */\nexport enum RepoArchivedAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n/** The merge options available for pull requests to this repository. */\nexport enum RepoChangeMergeSettingAuditEntryMergeType {\n  /** The pull request is added to the base branch in a merge commit. */\n  Merge = 'MERGE',\n  /** Commits from the pull request are added onto the base branch individually without a merge commit. */\n  Rebase = 'REBASE',\n  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */\n  Squash = 'SQUASH'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/** The privacy of a repository */\nexport enum RepoCreateAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n/** The privacy of a repository */\nexport enum RepoDestroyAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n/** The privacy of a repository */\nexport enum RepoRemoveMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n/** The reasons a piece of content can be reported or minimized. */\nexport enum ReportedContentClassifiers {\n  /** An abusive or harassing piece of content */\n  Abuse = 'ABUSE',\n  /** A duplicated piece of content */\n  Duplicate = 'DUPLICATE',\n  /** An irrelevant piece of content */\n  OffTopic = 'OFF_TOPIC',\n  /** An outdated piece of content */\n  Outdated = 'OUTDATED',\n  /** The content has been resolved */\n  Resolved = 'RESOLVED',\n  /** A spammy piece of content */\n  Spam = 'SPAM'\n}\n\n\n/** The affiliation of a user to a repository */\nexport enum RepositoryAffiliation {\n  /** Repositories that the user has been added to as a collaborator. */\n  Collaborator = 'COLLABORATOR',\n  /**\n   * Repositories that the user has access to through being a member of an\n   * organization. This includes every repository on every team that the user is on.\n   */\n  OrganizationMember = 'ORGANIZATION_MEMBER',\n  /** Repositories that are owned by the authenticated user. */\n  Owner = 'OWNER'\n}\n\n\n\n\n\n\n/** The reason a repository is listed as 'contributed'. */\nexport enum RepositoryContributionType {\n  /** Created a commit */\n  Commit = 'COMMIT',\n  /** Created an issue */\n  Issue = 'ISSUE',\n  /** Created a pull request */\n  PullRequest = 'PULL_REQUEST',\n  /** Reviewed a pull request */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** Created the repository */\n  Repository = 'REPOSITORY'\n}\n\n\n\n\n\n\n/** A repository interaction limit. */\nexport enum RepositoryInteractionLimit {\n  /** Users that are not collaborators will not be able to interact with the repository. */\n  CollaboratorsOnly = 'COLLABORATORS_ONLY',\n  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */\n  ContributorsOnly = 'CONTRIBUTORS_ONLY',\n  /** Users that have recently created their account will be unable to interact with the repository. */\n  ExistingUsers = 'EXISTING_USERS',\n  /** No interaction limits are enabled. */\n  NoLimit = 'NO_LIMIT'\n}\n\n/** The length for a repository interaction limit to be enabled for. */\nexport enum RepositoryInteractionLimitExpiry {\n  /** The interaction limit will expire after 1 day. */\n  OneDay = 'ONE_DAY',\n  /** The interaction limit will expire after 1 month. */\n  OneMonth = 'ONE_MONTH',\n  /** The interaction limit will expire after 1 week. */\n  OneWeek = 'ONE_WEEK',\n  /** The interaction limit will expire after 6 months. */\n  SixMonths = 'SIX_MONTHS',\n  /** The interaction limit will expire after 3 days. */\n  ThreeDays = 'THREE_DAYS'\n}\n\n/** Indicates where an interaction limit is configured. */\nexport enum RepositoryInteractionLimitOrigin {\n  /** A limit that is configured at the organization level. */\n  Organization = 'ORGANIZATION',\n  /** A limit that is configured at the repository level. */\n  Repository = 'REPOSITORY',\n  /** A limit that is configured at the user-wide level. */\n  User = 'USER'\n}\n\n\n\n\n/** Ordering options for repository invitation connections. */\nexport type RepositoryInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repository invitations by. */\n  field: RepositoryInvitationOrderField;\n};\n\n/** Properties by which repository invitation connections can be ordered. */\nexport enum RepositoryInvitationOrderField {\n  /** Order repository invitations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repository invitations by invitee login */\n  InviteeLogin = 'INVITEE_LOGIN'\n}\n\n/** The possible reasons a given repository could be in a locked state. */\nexport enum RepositoryLockReason {\n  /** The repository is locked due to a billing related reason. */\n  Billing = 'BILLING',\n  /** The repository is locked due to a migration. */\n  Migrating = 'MIGRATING',\n  /** The repository is locked due to a move. */\n  Moving = 'MOVING',\n  /** The repository is locked due to a rename. */\n  Rename = 'RENAME'\n}\n\n\n/** Ordering options for repository connections */\nexport type RepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: RepositoryOrderField;\n};\n\n/** Properties by which repository connections can be ordered. */\nexport enum RepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n/** The access level to a repository */\nexport enum RepositoryPermission {\n  /**\n   * Can read, clone, and push to this repository. Can also manage issues, pull\n   * requests, and repository settings, including adding collaborators\n   */\n  Admin = 'ADMIN',\n  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */\n  Maintain = 'MAINTAIN',\n  /** Can read and clone this repository. Can also open and comment on issues and pull requests */\n  Read = 'READ',\n  /** Can read and clone this repository. Can also manage issues and pull requests */\n  Triage = 'TRIAGE',\n  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */\n  Write = 'WRITE'\n}\n\n/** The privacy of a repository */\nexport enum RepositoryPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n\n\n\n/** The repository's visibility level. */\nexport enum RepositoryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n\n\n\n\n\n/** Autogenerated input type of RequestReviews */\nexport type RequestReviewsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID'];\n  /** The Node IDs of the team to request. */\n  teamIds?: Maybe<Array<Scalars['ID']>>;\n  /** Add users to the set rather than replace. */\n  union?: Maybe<Scalars['Boolean']>;\n  /** The Node IDs of the user to request. */\n  userIds?: Maybe<Array<Scalars['ID']>>;\n};\n\n\n/** The possible states that can be requested when creating a check run. */\nexport enum RequestableCheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n\n\n/** Autogenerated input type of RerequestCheckSuite */\nexport type RerequestCheckSuiteInput = {\n  /** The Node ID of the check suite. */\n  checkSuiteId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of ResolveReviewThread */\nexport type ResolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the thread to resolve */\n  threadId: Scalars['ID'];\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** The possible digest algorithms used to sign SAML requests for an identity provider. */\nexport enum SamlDigestAlgorithm {\n  /** SHA1 */\n  Sha1 = 'SHA1',\n  /** SHA256 */\n  Sha256 = 'SHA256',\n  /** SHA384 */\n  Sha384 = 'SHA384',\n  /** SHA512 */\n  Sha512 = 'SHA512'\n}\n\n/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */\nexport enum SamlSignatureAlgorithm {\n  /** RSA-SHA1 */\n  RsaSha1 = 'RSA_SHA1',\n  /** RSA-SHA256 */\n  RsaSha256 = 'RSA_SHA256',\n  /** RSA-SHA384 */\n  RsaSha384 = 'RSA_SHA384',\n  /** RSA-SHA512 */\n  RsaSha512 = 'RSA_SHA512'\n}\n\n\n\n\n/** Ordering options for saved reply connections. */\nexport type SavedReplyOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order saved replies by. */\n  field: SavedReplyOrderField;\n};\n\n/** Properties by which saved reply connections can be ordered. */\nexport enum SavedReplyOrderField {\n  /** Order saved reply by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n\n/** Represents the individual results of a search. */\nexport enum SearchType {\n  /** Returns matching discussions in repositories. */\n  Discussion = 'DISCUSSION',\n  /** Returns results matching issues in repositories. */\n  Issue = 'ISSUE',\n  /** Returns results matching repositories. */\n  Repository = 'REPOSITORY',\n  /** Returns results matching users and organizations on GitHub. */\n  User = 'USER'\n}\n\n\n\n/** The possible ecosystems of a security vulnerability's package. */\nexport enum SecurityAdvisoryEcosystem {\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS'\n}\n\n\n\n/** An advisory identifier to filter results on. */\nexport type SecurityAdvisoryIdentifierFilter = {\n  /** The identifier type. */\n  type: SecurityAdvisoryIdentifierType;\n  /** The identifier string. Supports exact or partial matching. */\n  value: Scalars['String'];\n};\n\n/** Identifier formats available for advisories. */\nexport enum SecurityAdvisoryIdentifierType {\n  /** Common Vulnerabilities and Exposures Identifier. */\n  Cve = 'CVE',\n  /** GitHub Security Advisory ID. */\n  Ghsa = 'GHSA'\n}\n\n/** Ordering options for security advisory connections */\nexport type SecurityAdvisoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security advisories by. */\n  field: SecurityAdvisoryOrderField;\n};\n\n/** Properties by which security advisory connections can be ordered. */\nexport enum SecurityAdvisoryOrderField {\n  /** Order advisories by publication time */\n  PublishedAt = 'PUBLISHED_AT',\n  /** Order advisories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n\n/** Severity of the vulnerability. */\nexport enum SecurityAdvisorySeverity {\n  /** Critical. */\n  Critical = 'CRITICAL',\n  /** High. */\n  High = 'HIGH',\n  /** Low. */\n  Low = 'LOW',\n  /** Moderate. */\n  Moderate = 'MODERATE'\n}\n\n\n\n\n/** Ordering options for security vulnerability connections */\nexport type SecurityVulnerabilityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security vulnerabilities by. */\n  field: SecurityVulnerabilityOrderField;\n};\n\n/** Properties by which security vulnerability connections can be ordered. */\nexport enum SecurityVulnerabilityOrderField {\n  /** Order vulnerability by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Autogenerated input type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod: SamlDigestAlgorithm;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID'];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate: Scalars['String'];\n  /** The Issuer Entity ID for the SAML identity provider */\n  issuer?: Maybe<Scalars['String']>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod: SamlSignatureAlgorithm;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl: Scalars['URI'];\n};\n\n\n/** Autogenerated input type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the organization to set a limit for. */\n  organizationId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the repository to set a limit for. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the user to set a limit for. */\n  userId: Scalars['ID'];\n};\n\n\n\n\n\n\n/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */\nexport type SponsorOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsor entities by. */\n  field: SponsorOrderField;\n};\n\n/** Properties by which sponsor connections can be ordered. */\nexport enum SponsorOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN',\n  /** Order sponsors by their relevance to the viewer. */\n  Relevance = 'RELEVANCE'\n}\n\n\n\n\n\n/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */\nexport type SponsorableOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorable entities by. */\n  field: SponsorableOrderField;\n};\n\n/** Properties by which sponsorable connections can be ordered. */\nexport enum SponsorableOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN'\n}\n\n\n/** The possible actions that GitHub Sponsors activities can represent. */\nexport enum SponsorsActivityAction {\n  /** The activity was cancelling a sponsorship. */\n  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',\n  /** The activity was starting a sponsorship. */\n  NewSponsorship = 'NEW_SPONSORSHIP',\n  /** The activity was scheduling a downgrade or cancellation. */\n  PendingChange = 'PENDING_CHANGE',\n  /** The activity was funds being refunded to the sponsor or GitHub. */\n  Refund = 'REFUND',\n  /** The activity was disabling matching for a previously matched sponsorship. */\n  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',\n  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */\n  TierChange = 'TIER_CHANGE'\n}\n\n\n\n/** Ordering options for GitHub Sponsors activity connections. */\nexport type SponsorsActivityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order activity by. */\n  field: SponsorsActivityOrderField;\n};\n\n/** Properties by which GitHub Sponsors activity connections can be ordered. */\nexport enum SponsorsActivityOrderField {\n  /** Order activities by when they happened. */\n  Timestamp = 'TIMESTAMP'\n}\n\n/** The possible time periods for which Sponsors activities can be requested. */\nexport enum SponsorsActivityPeriod {\n  /** Don't restrict the activity to any date range, include all activity. */\n  All = 'ALL',\n  /** The previous calendar day. */\n  Day = 'DAY',\n  /** The previous thirty days. */\n  Month = 'MONTH',\n  /** The previous seven days. */\n  Week = 'WEEK'\n}\n\n\n/** The different kinds of goals a GitHub Sponsors member can have. */\nexport enum SponsorsGoalKind {\n  /** The goal is about getting a certain dollar amount from sponsorships each month. */\n  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',\n  /** The goal is about reaching a certain number of sponsors. */\n  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'\n}\n\n\n\n\n\n\n/** Ordering options for Sponsors tiers connections. */\nexport type SponsorsTierOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order tiers by. */\n  field: SponsorsTierOrderField;\n};\n\n/** Properties by which Sponsors tiers connections can be ordered. */\nexport enum SponsorsTierOrderField {\n  /** Order tiers by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order tiers by their monthly price in cents */\n  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'\n}\n\n\n\n\n\n\n\n/** Ordering options for sponsorship newsletter connections. */\nexport type SponsorshipNewsletterOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship newsletters by. */\n  field: SponsorshipNewsletterOrderField;\n};\n\n/** Properties by which sponsorship update connections can be ordered. */\nexport enum SponsorshipNewsletterOrderField {\n  /** Order sponsorship newsletters by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ordering options for sponsorship connections. */\nexport type SponsorshipOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship by. */\n  field: SponsorshipOrderField;\n};\n\n/** Properties by which sponsorship connections can be ordered. */\nexport enum SponsorshipOrderField {\n  /** Order sponsorship by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The privacy of a sponsorship */\nexport enum SponsorshipPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n/** Ways in which star connections can be ordered. */\nexport type StarOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: StarOrderField;\n};\n\n/** Properties by which star connections can be ordered. */\nexport enum StarOrderField {\n  /** Allows ordering a list of stars by when they were created. */\n  StarredAt = 'STARRED_AT'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/** The possible commit status states. */\nexport enum StatusState {\n  /** Status is errored. */\n  Error = 'ERROR',\n  /** Status is expected. */\n  Expected = 'EXPECTED',\n  /** Status is failing. */\n  Failure = 'FAILURE',\n  /** Status is pending. */\n  Pending = 'PENDING',\n  /** Status is successful. */\n  Success = 'SUCCESS'\n}\n\n/** Autogenerated input type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewInput = {\n  /** The text field to set on the Pull Request Review. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The event to send to the Pull Request Review. */\n  event: PullRequestReviewEvent;\n  /** The Pull Request ID to submit any pending reviews. */\n  pullRequestId?: Maybe<Scalars['ID']>;\n  /** The Pull Request Review ID to submit. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>;\n};\n\n\n\n\n\n\n\n/** The possible states of a subscription. */\nexport enum SubscriptionState {\n  /** The User is never notified. */\n  Ignored = 'IGNORED',\n  /** The User is notified of all conversations. */\n  Subscribed = 'SUBSCRIBED',\n  /** The User is only notified when participating or @mentioned. */\n  Unsubscribed = 'UNSUBSCRIBED'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Ways in which team discussion comment connections can be ordered. */\nexport type TeamDiscussionCommentOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionCommentOrderField;\n};\n\n/** Properties by which team discussion comment connections can be ordered. */\nexport enum TeamDiscussionCommentOrderField {\n  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */\n  Number = 'NUMBER'\n}\n\n\n\n/** Ways in which team discussion connections can be ordered. */\nexport type TeamDiscussionOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionOrderField;\n};\n\n/** Properties by which team discussion connections can be ordered. */\nexport enum TeamDiscussionOrderField {\n  /** Allows chronological ordering of team discussions. */\n  CreatedAt = 'CREATED_AT'\n}\n\n\n\n\n/** Ordering options for team member connections */\nexport type TeamMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order team members by. */\n  field: TeamMemberOrderField;\n};\n\n/** Properties by which team member connections can be ordered. */\nexport enum TeamMemberOrderField {\n  /** Order team members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order team members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible team member roles; either 'maintainer' or 'member'. */\nexport enum TeamMemberRole {\n  /** A team maintainer has permission to add and remove team members. */\n  Maintainer = 'MAINTAINER',\n  /** A team member has no administrative permissions on the team. */\n  Member = 'MEMBER'\n}\n\n/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */\nexport enum TeamMembershipType {\n  /** Includes immediate and child team members for the team. */\n  All = 'ALL',\n  /** Includes only child team members for the team. */\n  ChildTeam = 'CHILD_TEAM',\n  /** Includes only immediate members of the team. */\n  Immediate = 'IMMEDIATE'\n}\n\n/** Ways in which team connections can be ordered. */\nexport type TeamOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: TeamOrderField;\n};\n\n/** Properties by which team connections can be ordered. */\nexport enum TeamOrderField {\n  /** Allows ordering a list of teams by name. */\n  Name = 'NAME'\n}\n\n/** The possible team privacy values. */\nexport enum TeamPrivacy {\n  /** A secret team can only be seen by its members. */\n  Secret = 'SECRET',\n  /** A visible team can be seen and @mentioned by every member of the organization. */\n  Visible = 'VISIBLE'\n}\n\n\n\n\n\n/** Ordering options for team repository connections */\nexport type TeamRepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: TeamRepositoryOrderField;\n};\n\n/** Properties by which team repository connections can be ordered. */\nexport enum TeamRepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by permission */\n  Permission = 'PERMISSION',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible team review assignment algorithms */\nexport enum TeamReviewAssignmentAlgorithm {\n  /** Balance review load across the entire team */\n  LoadBalance = 'LOAD_BALANCE',\n  /** Alternate reviews between each team member */\n  RoundRobin = 'ROUND_ROBIN'\n}\n\n/** The role of a user on a team. */\nexport enum TeamRole {\n  /** User has admin rights on the team. */\n  Admin = 'ADMIN',\n  /** User is a member of the team. */\n  Member = 'MEMBER'\n}\n\n\n\n\n\n/** Reason that the suggested topic is declined. */\nexport enum TopicSuggestionDeclineReason {\n  /** The suggested topic is not relevant to the repository. */\n  NotRelevant = 'NOT_RELEVANT',\n  /** The viewer does not like the suggested topic. */\n  PersonalPreference = 'PERSONAL_PREFERENCE',\n  /** The suggested topic is too general for the repository. */\n  TooGeneral = 'TOO_GENERAL',\n  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */\n  TooSpecific = 'TOO_SPECIFIC'\n}\n\n/** Autogenerated input type of TransferIssue */\nexport type TransferIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the issue to be transferred */\n  issueId: Scalars['ID'];\n  /** The Node ID of the repository the issue should be transferred to */\n  repositoryId: Scalars['ID'];\n};\n\n\n\n\n\n\n/** Autogenerated input type of UnarchiveRepository */\nexport type UnarchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the repository to unarchive. */\n  repositoryId: Scalars['ID'];\n};\n\n\n\n/** Autogenerated input type of UnfollowUser */\nexport type UnfollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the user to unfollow. */\n  userId: Scalars['ID'];\n};\n\n\n\n\n\n/** Autogenerated input type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Project linked to the Repository. */\n  projectId: Scalars['ID'];\n  /** The ID of the Repository linked to the Project. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UnlockLockable */\nexport type UnlockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the item to be unlocked. */\n  lockableId: Scalars['ID'];\n};\n\n\n\n/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to unmark as an answer. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The path of the file to mark as unviewed */\n  path: Scalars['String'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicateInput = {\n  /** ID of the issue or pull request currently considered canonical/authoritative/original. */\n  canonicalId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** ID of the issue or pull request currently marked as a duplicate. */\n  duplicateId: Scalars['ID'];\n};\n\n\n\n/** Autogenerated input type of UnminimizeComment */\nexport type UnminimizeCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UnpinIssue */\nexport type UnpinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the issue to be unpinned */\n  issueId: Scalars['ID'];\n};\n\n\n\n/** Autogenerated input type of UnresolveReviewThread */\nexport type UnresolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the thread to unresolve */\n  threadId: Scalars['ID'];\n};\n\n\n\n\n\n/** Autogenerated input type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: Maybe<Scalars['Boolean']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: Maybe<Scalars['Boolean']>;\n  /** The global relay id of the branch protection rule to be updated. */\n  branchProtectionRuleId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: Maybe<Scalars['Boolean']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern?: Maybe<Scalars['String']>;\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: Maybe<Array<Scalars['ID']>>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: Maybe<Scalars['Boolean']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: Maybe<Scalars['Boolean']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: Maybe<Scalars['Boolean']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: Maybe<Scalars['Boolean']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;\n};\n\n\n/** Autogenerated input type of UpdateCheckRun */\nexport type UpdateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: Maybe<Array<CheckRunAction>>;\n  /** The node of the check. */\n  checkRunId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The time that the check run finished. */\n  completedAt?: Maybe<Scalars['DateTime']>;\n  /** The final conclusion of the check. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: Maybe<Scalars['URI']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>;\n  /** The name of the check. */\n  name?: Maybe<Scalars['String']>;\n  /** Descriptive details about the run. */\n  output?: Maybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The time that the check run began. */\n  startedAt?: Maybe<Scalars['DateTime']>;\n  /** The current status. */\n  status?: Maybe<RequestableCheckStatusState>;\n};\n\n\n/** Autogenerated input type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesInput = {\n  /** The check suite preferences to modify. */\n  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentInput = {\n  /** The new contents of the comment body. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to update. */\n  commentId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateDiscussion */\nexport type UpdateDiscussionInput = {\n  /** The new contents of the discussion body. */\n  body?: Maybe<Scalars['String']>;\n  /** The Node ID of a discussion category within the same repository to change this discussion to. */\n  categoryId?: Maybe<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion to update. */\n  discussionId: Scalars['ID'];\n  /** The new discussion title. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a administrator whose role is being changed. */\n  login: Scalars['String'];\n  /** The new role for the Enterprise administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the allow private repository forking setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the allow private repository forking setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the base repository permission setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the base repository permission setting on the enterprise. */\n  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can change repository visibility setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can change repository visibility setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can create repositories setting. */\n  enterpriseId: Scalars['ID'];\n  /** Allow members to create internal repositories. Defaults to current value. */\n  membersCanCreateInternalRepositories?: Maybe<Scalars['Boolean']>;\n  /** Allow members to create private repositories. Defaults to current value. */\n  membersCanCreatePrivateRepositories?: Maybe<Scalars['Boolean']>;\n  /** Allow members to create public repositories. Defaults to current value. */\n  membersCanCreatePublicRepositories?: Maybe<Scalars['Boolean']>;\n  /** When false, allow member organizations to set their own repository creation member privileges. */\n  membersCanCreateRepositoriesPolicyEnabled?: Maybe<Scalars['Boolean']>;\n  /**\n   * Value for the members can create repositories setting on the enterprise. This\n   * or the granular public/private/internal allowed fields (but not both) must be provided.\n   */\n  settingValue?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can delete issues setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can delete issues setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can delete repositories setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can delete repositories setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can invite collaborators setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can invite collaborators setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can make purchases setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can make purchases setting on the enterprise. */\n  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can update protected branches setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can update protected branches setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can view dependency insights setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can view dependency insights setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the organization projects setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the organization projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfileInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars['String']>;\n  /** The Enterprise ID to update. */\n  enterpriseId: Scalars['ID'];\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars['String']>;\n  /** The name of the enterprise. */\n  name?: Maybe<Scalars['String']>;\n  /** The URL of the enterprise's website. */\n  websiteUrl?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the repository projects setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the repository projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the team discussions setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the team discussions setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the two factor authentication required setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the two factor authentication required setting on the enterprise. */\n  settingValue: EnterpriseEnabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateEnvironment */\nexport type UpdateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The node ID of the environment. */\n  environmentId: Scalars['ID'];\n  /** The ids of users or teams that can approve deployments to this environment */\n  reviewers?: Maybe<Array<Scalars['ID']>>;\n  /** The wait timer in minutes. */\n  waitTimer?: Maybe<Scalars['Int']>;\n};\n\n\n/** Autogenerated input type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the owner on which to set the IP allow list enabled setting. */\n  ownerId: Scalars['ID'];\n  /** The value for the IP allow list enabled setting. */\n  settingValue: IpAllowListEnabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the IP allow list entry to update. */\n  ipAllowListEntryId: Scalars['ID'];\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean'];\n  /** An optional name for the IP allow list entry. */\n  name?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the owner. */\n  ownerId: Scalars['ID'];\n  /** The value for the IP allow list configuration for installed GitHub Apps setting. */\n  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateIssueComment */\nexport type UpdateIssueCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the IssueComment to modify. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateIssue */\nexport type UpdateIssueInput = {\n  /** An array of Node IDs of users for this issue. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>;\n  /** The body for the issue description. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the Issue to modify. */\n  id: Scalars['ID'];\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: Maybe<Array<Scalars['ID']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: Maybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: Maybe<Array<Scalars['ID']>>;\n  /** The desired issue state. */\n  state?: Maybe<IssueState>;\n  /** The title for the issue. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateLabel */\nexport type UpdateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */\n  color?: Maybe<Scalars['String']>;\n  /** A brief description of the label, such as its purpose. */\n  description?: Maybe<Scalars['String']>;\n  /** The Node ID of the label to be updated. */\n  id: Scalars['ID'];\n  /** The updated name of the label. */\n  name?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the owner on which to set the restrict notifications setting. */\n  ownerId: Scalars['ID'];\n  /** The value for the restrict notifications setting. */\n  settingValue: NotificationRestrictionSettingValue;\n};\n\n\n/** Autogenerated input type of UpdateProjectCard */\nexport type UpdateProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Whether or not the ProjectCard should be archived */\n  isArchived?: Maybe<Scalars['Boolean']>;\n  /** The note of ProjectCard. */\n  note?: Maybe<Scalars['String']>;\n  /** The ProjectCard ID to update. */\n  projectCardId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateProjectColumn */\nexport type UpdateProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of project column. */\n  name: Scalars['String'];\n  /** The ProjectColumn ID to update. */\n  projectColumnId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateProject */\nexport type UpdateProjectInput = {\n  /** The description of project. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The name of project. */\n  name?: Maybe<Scalars['String']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID'];\n  /** Whether the project is public or not. */\n  public?: Maybe<Scalars['Boolean']>;\n  /** Whether the project is open or closed. */\n  state?: Maybe<ProjectState>;\n};\n\n\n/** Autogenerated input type of UpdatePullRequest */\nexport type UpdatePullRequestInput = {\n  /** An array of Node IDs of users for this pull request. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>;\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository.\n   */\n  baseRefName?: Maybe<Scalars['String']>;\n  /** The contents of the pull request. */\n  body?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** An array of Node IDs of labels for this pull request. */\n  labelIds?: Maybe<Array<Scalars['ID']>>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: Maybe<Scalars['Boolean']>;\n  /** The Node ID of the milestone for this pull request. */\n  milestoneId?: Maybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this pull request. */\n  projectIds?: Maybe<Array<Scalars['ID']>>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n  /** The target state of the pull request. */\n  state?: Maybe<PullRequestUpdateState>;\n  /** The title of the pull request. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the comment to modify. */\n  pullRequestReviewCommentId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewInput = {\n  /** The contents of the pull request review body. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateRef */\nexport type UpdateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Permit updates of branch Refs that are not fast-forwards? */\n  force?: Maybe<Scalars['Boolean']>;\n  /** The GitObjectID that the Ref shall be updated to target. */\n  oid: Scalars['GitObjectID'];\n  /** The Node ID of the Ref to be updated. */\n  refId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateRefs */\nexport type UpdateRefsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A list of ref updates. */\n  refUpdates: Array<RefUpdate>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateRepository */\nexport type UpdateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A new description for the repository. Pass an empty string to erase the existing description. */\n  description?: Maybe<Scalars['String']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the project boards feature enabled. */\n  hasProjectsEnabled?: Maybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: Maybe<Scalars['Boolean']>;\n  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */\n  homepageUrl?: Maybe<Scalars['URI']>;\n  /** The new name of the repository. */\n  name?: Maybe<Scalars['String']>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID'];\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: Maybe<Scalars['Boolean']>;\n};\n\n\n/** Autogenerated input type of UpdateSubscription */\nexport type UpdateSubscriptionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new state of the subscription. */\n  state: SubscriptionState;\n  /** The Node ID of the subscribable object to modify. */\n  subscribableId: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String'];\n  /** The current version of the body content. */\n  bodyVersion?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the comment to modify. */\n  id: Scalars['ID'];\n};\n\n\n/** Autogenerated input type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionInput = {\n  /** The updated text of the discussion. */\n  body?: Maybe<Scalars['String']>;\n  /**\n   * The current version of the body content. If provided, this update operation\n   * will be rejected if the given version does not match the latest version on the server.\n   */\n  bodyVersion?: Maybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the discussion to modify. */\n  id: Scalars['ID'];\n  /** If provided, sets the pinned state of the updated discussion. */\n  pinned?: Maybe<Scalars['Boolean']>;\n  /** The updated title of the discussion. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** Autogenerated input type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentInput = {\n  /** The algorithm to use for review assignment */\n  algorithm?: Maybe<TeamReviewAssignmentAlgorithm>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Turn on or off review assignment */\n  enabled: Scalars['Boolean'];\n  /** An array of team member IDs to exclude */\n  excludedTeamMemberIds?: Maybe<Array<Scalars['ID']>>;\n  /** The Node ID of the team to update review assignments of */\n  id: Scalars['ID'];\n  /** Notify the entire team of the PR if it is delegated */\n  notifyTeam?: Maybe<Scalars['Boolean']>;\n  /** The number of team members to assign */\n  teamMemberCount?: Maybe<Scalars['Int']>;\n};\n\n\n/** Autogenerated input type of UpdateTopics */\nexport type UpdateTopicsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** An array of topic names. */\n  topicNames: Array<Scalars['String']>;\n};\n\n\n\n/** The possible durations that a user can be blocked for. */\nexport enum UserBlockDuration {\n  /** The user was blocked for 1 day */\n  OneDay = 'ONE_DAY',\n  /** The user was blocked for 30 days */\n  OneMonth = 'ONE_MONTH',\n  /** The user was blocked for 7 days */\n  OneWeek = 'ONE_WEEK',\n  /** The user was blocked permanently */\n  Permanent = 'PERMANENT',\n  /** The user was blocked for 3 days */\n  ThreeDays = 'THREE_DAYS'\n}\n\n\n\n\n\n\n\n\n\n\n\n/** Ordering options for user status connections. */\nexport type UserStatusOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user statuses by. */\n  field: UserStatusOrderField;\n};\n\n/** Properties by which user status connections can be ordered. */\nexport enum UserStatusOrderField {\n  /** Order user statuses by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n\n\n\n/** Ordering options for verifiable domain connections. */\nexport type VerifiableDomainOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order verifiable domains by. */\n  field: VerifiableDomainOrderField;\n};\n\n/** Properties by which verifiable domain connections can be ordered. */\nexport enum VerifiableDomainOrderField {\n  /** Order verifiable domains by their creation date. */\n  CreatedAt = 'CREATED_AT',\n  /** Order verifiable domains by the domain name. */\n  Domain = 'DOMAIN'\n}\n\n\n/** Autogenerated input type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the verifiable domain to verify. */\n  id: Scalars['ID'];\n};\n\n\n\n\n\n\n\nexport type UserQueryVariables = Exact<{\n  user: Scalars['String'];\n}>;\n\n\nexport type UserQuery = { data?: Maybe<{ name?: Maybe<string>, websiteUrl?: Maybe<any>, url: any, description?: Maybe<string> }> };\n\nexport type DiscussionCategoriesQueryVariables = Exact<{\n  owner: Scalars['String'];\n  name: Scalars['String'];\n  count: Scalars['Int'];\n}>;\n\n\nexport type DiscussionCategoriesQuery = { repository?: Maybe<{ discussionCategories: { nodes?: Maybe<Array<Maybe<{ id: string, name: string }>>> } }> };\n\nexport type DiscussionsQueryVariables = Exact<{\n  owner: Scalars['String'];\n  name: Scalars['String'];\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  categoryId?: Maybe<Scalars['ID']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  orderBy?: Maybe<DiscussionOrder>;\n  labelsCount: Scalars['Int'];\n}>;\n\n\nexport type DiscussionsQuery = { repository?: Maybe<{ discussions: { totalCount: number, pageInfo: { hasPreviousPage: boolean, startCursor?: Maybe<string>, hasNextPage: boolean, endCursor?: Maybe<string> }, nodes?: Maybe<Array<Maybe<{ number: number, title: string, createdAt: any, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> }>>> } }> };\n\nexport type LabelItemFragment = { color: string, name: string };\n\nexport type PostItemFragment = { number: number, title: string, createdAt: any, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> };\n\nexport type DiscussionQueryVariables = Exact<{\n  owner: Scalars['String'];\n  name: Scalars['String'];\n  number: Scalars['Int'];\n  labelsCount: Scalars['Int'];\n}>;\n\n\nexport type DiscussionQuery = { repository?: Maybe<{ discussion?: Maybe<{ number: number, title: string, updatedAt: any, bodyHTML: any, url: any, upvoteCount: number, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> }> }> };\n\nexport type PostDetailFragment = { number: number, title: string, updatedAt: any, bodyHTML: any, url: any, upvoteCount: number, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> };\n\nexport const LabelItemFragmentDoc = `\n    fragment LabelItem on Label {\n  color\n  name\n}\n    `;\nexport const PostItemFragmentDoc = `\n    fragment PostItem on Discussion {\n  number\n  title\n  createdAt\n  labels(first: $labelsCount) {\n    nodes {\n      ...LabelItem\n    }\n  }\n}\n    ${LabelItemFragmentDoc}`;\nexport const PostDetailFragmentDoc = `\n    fragment PostDetail on Discussion {\n  number\n  title\n  updatedAt\n  bodyHTML\n  url\n  upvoteCount\n  labels(first: $labelsCount) {\n    nodes {\n      ...LabelItem\n    }\n  }\n}\n    ${LabelItemFragmentDoc}`;\nexport const UserDocument = `\n    query user($user: String!) {\n  data: user(login: $user) {\n    name\n    websiteUrl\n    url\n    description: bio\n  }\n}\n    `;\nexport const useUserQuery = <\n      TData = UserQuery,\n      TError = unknown\n    >(\n      variables: UserQueryVariables, \n      options?: UseQueryOptions<UserQuery, TError, TData>\n    ) => \n    useQuery<UserQuery, TError, TData>(\n      ['user', variables],\n      fetchData<UserQuery, UserQueryVariables>(UserDocument, variables),\n      options\n    );\nuseUserQuery.fetcher = (variables: UserQueryVariables) => fetchData<UserQuery, UserQueryVariables>(UserDocument, variables);\nexport const DiscussionCategoriesDocument = `\n    query discussionCategories($owner: String!, $name: String!, $count: Int!) {\n  repository(owner: $owner, name: $name) {\n    discussionCategories(first: $count) {\n      nodes {\n        id\n        name\n      }\n    }\n  }\n}\n    `;\nexport const useDiscussionCategoriesQuery = <\n      TData = DiscussionCategoriesQuery,\n      TError = unknown\n    >(\n      variables: DiscussionCategoriesQueryVariables, \n      options?: UseQueryOptions<DiscussionCategoriesQuery, TError, TData>\n    ) => \n    useQuery<DiscussionCategoriesQuery, TError, TData>(\n      ['discussionCategories', variables],\n      fetchData<DiscussionCategoriesQuery, DiscussionCategoriesQueryVariables>(DiscussionCategoriesDocument, variables),\n      options\n    );\nuseDiscussionCategoriesQuery.fetcher = (variables: DiscussionCategoriesQueryVariables) => fetchData<DiscussionCategoriesQuery, DiscussionCategoriesQueryVariables>(DiscussionCategoriesDocument, variables);\nexport const DiscussionsDocument = `\n    query discussions($owner: String!, $name: String!, $after: String, $before: String, $categoryId: ID, $first: Int, $last: Int, $orderBy: DiscussionOrder, $labelsCount: Int!) {\n  repository(owner: $owner, name: $name) {\n    discussions(\n      after: $after\n      before: $before\n      categoryId: $categoryId\n      first: $first\n      last: $last\n      orderBy: $orderBy\n    ) {\n      pageInfo {\n        hasPreviousPage\n        startCursor\n        hasNextPage\n        endCursor\n      }\n      totalCount\n      nodes {\n        ...PostItem\n      }\n    }\n  }\n}\n    ${PostItemFragmentDoc}`;\nexport const useDiscussionsQuery = <\n      TData = DiscussionsQuery,\n      TError = unknown\n    >(\n      variables: DiscussionsQueryVariables, \n      options?: UseQueryOptions<DiscussionsQuery, TError, TData>\n    ) => \n    useQuery<DiscussionsQuery, TError, TData>(\n      ['discussions', variables],\n      fetchData<DiscussionsQuery, DiscussionsQueryVariables>(DiscussionsDocument, variables),\n      options\n    );\nuseDiscussionsQuery.fetcher = (variables: DiscussionsQueryVariables) => fetchData<DiscussionsQuery, DiscussionsQueryVariables>(DiscussionsDocument, variables);\nexport const DiscussionDocument = `\n    query discussion($owner: String!, $name: String!, $number: Int!, $labelsCount: Int!) {\n  repository(owner: $owner, name: $name) {\n    discussion(number: $number) {\n      ...PostDetail\n    }\n  }\n}\n    ${PostDetailFragmentDoc}`;\nexport const useDiscussionQuery = <\n      TData = DiscussionQuery,\n      TError = unknown\n    >(\n      variables: DiscussionQueryVariables, \n      options?: UseQueryOptions<DiscussionQuery, TError, TData>\n    ) => \n    useQuery<DiscussionQuery, TError, TData>(\n      ['discussion', variables],\n      fetchData<DiscussionQuery, DiscussionQueryVariables>(DiscussionDocument, variables),\n      options\n    );\nuseDiscussionQuery.fetcher = (variables: DiscussionQueryVariables) => fetchData<DiscussionQuery, DiscussionQueryVariables>(DiscussionDocument, variables);","interface Config {\n  caesarOffset: number;\n  encryptedToken: string;\n  user: string;\n  repository: string;\n  perpage: number;\n  orderBy: string | null;\n  postCategoryId: string;\n  labelsCount: number;\n}\nconst config: Config = {\n  caesarOffset: 4,\n  encryptedToken: \"kltcRpokQ[xi\\\\tSjj}6TEt8GtG~{{oG9hz7]UO~P\",\n  user: \"YeungKC\",\n  repository: \"YeungKC.github.io\",\n  perpage: 10,\n  orderBy: \"CREATED_AT\",\n  postCategoryId: \"DIC_kwDOF8LZSc4B-xAD\",\n  labelsCount: 64,\n};\nexport default config;\n","import config from \"../config\";\n\nconst rot = (text: String, offset: number) =>\n  text\n    .split(\"\")\n    .map((char) => String.fromCharCode(char.charCodeAt(0) + offset))\n    .join(\"\");\n\nconst encode = (text: String) => rot(text, config.caesarOffset);\nconst decode = (text: String) => rot(text, -config.caesarOffset);\nexport { encode, decode };\n","import config from \"../config\";\nimport { decode } from \"./caesar_cipher\";\n\nconst token = decode(config.encryptedToken);\n\nexport const fetchData =\n  <TData, TVariables>(query: string, variables?: TVariables): (() => Promise<TData>) =>\n  async () => {\n    const res = await fetch(\"https://api.github.com/graphql\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `bearer ${token}`,\n      },\n      body: JSON.stringify({\n        query,\n        variables,\n      }),\n    });\n\n    const json = await res.json();\n\n    if (json.errors) {\n      const { message } = json.errors[0] || \"Error..\";\n      throw new Error(message);\n    }\n\n    return json.data;\n  };\n","import config from \"../config\";\nimport { useDiscussionQuery } from \"./types-and-hooks\";\n\nconst cacheTime = 1000 * 60 * 60;\n\nexport default function useDiscussion(number: string) {\n  return useDiscussionQuery(\n    {\n      owner: config.user,\n      name: config.repository,\n      number: Number(number),\n      labelsCount: config.labelsCount,\n    },\n    {\n      staleTime: cacheTime,\n      cacheTime,\n    }\n  );\n}\n","const months = \"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\".split(\",\");\nexport default function formatTime(time: string) {\n  const date = new Date(time);\n  const day = date.getDate();\n  const index = date.getMonth();\n  const year = date.getFullYear();\n  return `${months[index]} ${day}, ${year}`;\n}\n","import { Box, FlexBox } from \"react-styled-flex\";\nimport styled from \"styled-components\";\nimport { LabelItemFragment, Maybe } from \"../api/types-and-hooks\";\nimport config from \"../config\";\nimport formatTime from \"../hepler/time\";\n\nfunction PostInfo({ time, labels }: { time: string; labels: Maybe<LabelItemFragment>[] }) {\n  return (\n    <Wrapper wrap>\n      {formatTime(time)}\n      {[labels.length > 0 && <Box margin=\"0 4px\">|</Box>, labels.map((label) => <Label data={label!} />)]}\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled(FlexBox)`\n  color: #999;\n`;\n\nfunction Label({ data }: { data: LabelItemFragment }) {\n  return (\n    <LabelWrapper href={`https://github.com/${config.user}/${config.repository}/discussions?discussions_q=label%3A${data.name}`} color={data.color}>\n      #{data.name}\n    </LabelWrapper>\n  );\n}\n\nfunction Time({ time }: { time: string }) {\n  return <Wrapper>{formatTime(time)}</Wrapper>;\n}\n\nconst LabelWrapper = styled.a`\n  margin: 0 4px;\n  padding: 1px 6px 2px 6px;\n  background-color: ${({ color }) => `#${color}4D`};\n  border-radius: 4px;\n  font-size: 13px;\n  color: #666;\n  &:hover {\n    text-decoration: none};\n  }\n`;\n\nexport { PostInfo, Label, Time };\n","import \"github-markdown-css\";\nimport { useParams } from \"react-router-dom\";\nimport { Box, FlexBox } from \"react-styled-flex\";\nimport styled from \"styled-components\";\nimport useDiscussion from \"../api/discussion\";\nimport NotFound from \"./not_found\";\nimport { PostInfo } from \"./post_info\";\n\nexport default function Post() {\n  const { id } = useParams<{ id: string }>();\n  const { isLoading, data, isError } = useDiscussion(id);\n\n  if (isLoading) {\n    return <div></div>;\n  }\n\n  if (isError) {\n    return <NotFound />;\n  }\n\n  const discussion = data?.repository?.discussion;\n  const labels = discussion?.labels?.nodes ?? [];\n\n  return (\n    <FlexBox column>\n      <Title>{discussion?.title}</Title>\n      <Box margin=\"8px 0 48px 0\">\n        <PostInfo time={discussion!.updatedAt} labels={labels} />\n      </Box>\n      <div className=\"markdown-body\" dangerouslySetInnerHTML={{ __html: discussion?.bodyHTML }} />\n    </FlexBox>\n  );\n}\n\nconst Title = styled.div`\n  font-size: 24px;\n`;\n","import { useInfiniteQuery } from \"react-query\";\nimport config from \"../config\";\nimport { DiscussionOrderField, OrderDirection, useDiscussionsQuery } from \"./types-and-hooks\";\n\nconst cacheTime = 1000 * 60 * 60;\n\nexport default function useDiscussions() {\n  return useInfiniteQuery(\n    \"posts\",\n    (params) => {\n      return useDiscussionsQuery.fetcher({\n        owner: config.user,\n        name: config.repository,\n        categoryId: config.postCategoryId,\n        first: config.perpage,\n        after: params.pageParam,\n        orderBy: {\n          field: config.orderBy === \"UPDATED_AT\" ? DiscussionOrderField.UpdatedAt : DiscussionOrderField.CreatedAt,\n          direction: OrderDirection.Desc,\n        },\n        labelsCount: config.labelsCount,\n      })();\n    },\n    {\n      staleTime: cacheTime,\n      cacheTime,\n      getNextPageParam: (lastPage) => {\n        const pageInfo = lastPage.repository?.discussions.pageInfo;\n        return pageInfo?.hasNextPage && pageInfo?.endCursor;\n      },\n    }\n  );\n}\n","import { Link } from \"react-router-dom\";\nimport { Box, FlexBox } from \"react-styled-flex\";\nimport styled from \"styled-components\";\nimport { PostItemFragment } from \"../api/types-and-hooks\";\nimport { Label, Time } from \"./post_info\";\n\nexport default function PostItem({ data }: { data: PostItemFragment }) {\n  return (\n    <Wrapper to={`/post/${data?.number}`}>\n      <FlexBox column key={data!.number} padding=\"20px 10px\">\n        <Title>{data?.title}</Title>\n        <FlexBox marginTop=\"12px\" justifyContent=\"space-between\">\n          <Box>\n            {data?.labels?.nodes?.map((label) => (\n              <Label data={label!} />\n            ))}\n          </Box>\n          <Time time={data!.createdAt} />\n        </FlexBox>\n      </FlexBox>\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled(Link)`\n  width=\"100%\";\n  &:hover {\n    background-color: #f5f5f5;\n    border-radius: 8px;\n    text-decoration: none;\n  }\n  color: inherit;\n`;\n\nconst Title = styled.div`\n  font-size: 17px;\n`;\n","import useIntersectionObserver from \"@react-hook/intersection-observer\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { FlexBox } from \"react-styled-flex\";\nimport useDiscussions from \"../api/discussions\";\nimport PostItem from \"./post_item\";\n\nexport default function Posts() {\n  const { data, isLoading, hasNextPage, fetchNextPage } = useDiscussions();\n  const discussions = useMemo(\n    () => data?.pages.map((item) => item.repository?.discussions.nodes).reduce((previousValue, currentValue = []) => [...(previousValue ?? []), ...(currentValue ?? [])], []) ?? [],\n    // eslint-disable-next-line\n    [data?.pageParams]\n  );\n  const ref = useRef(null);\n  const isBottomVisible = useIntersectionObserver(ref);\n\n  useEffect(() => {\n    if (isLoading) return;\n    if (!hasNextPage) return;\n    if (!isBottomVisible) return;\n    fetchNextPage();\n    // eslint-disable-next-line\n  }, [isLoading, hasNextPage, isBottomVisible, data?.pageParams]);\n\n  return (\n    <FlexBox column width=\"100%\">\n      {discussions.map((node, index) => (\n        <PostItem key={node?.number} data={node!} />\n      ))}\n      <div ref={ref} />\n    </FlexBox>\n  );\n}\n","import Posts from \"./posts\";\n\nexport default function Home() {\n  return <Posts />;\n}\n","import config from \"../config\";\nimport { useUserQuery } from \"./types-and-hooks\";\n\nconst cacheTime = 1000 * 60 * 60 * 24;\n\nexport default function useInfo() {\n  return useUserQuery(\n    { user: config.user },\n    {\n      staleTime: cacheTime,\n      cacheTime,\n    }\n  );\n}\n","import { Link } from \"react-router-dom\";\nimport { Box, FlexBox } from \"react-styled-flex\";\nimport styled from \"styled-components\";\nimport useInfo from \"../api/info\";\n\nexport default function UserInfo() {\n  const { isLoading, data } = useInfo();\n  const info = data?.data;\n\n  if (isLoading || !info) {\n    return <div></div>;\n  }\n\n  return (\n    <FlexBox column alignItems=\"center\" as=\"header\">\n      <Name to=\"/\">{info.name}'s Blog</Name>\n      <Description>{info.description}</Description>\n      <FlexBox marginTop=\"8px\">\n        <a href={info.url}>GitHub</a>\n        {info.websiteUrl && [<Box width=\"8px\" />, <a href={info.websiteUrl}>Home</a>]}\n      </FlexBox>\n      <Divider />\n    </FlexBox>\n  );\n}\n\nconst Name = styled(Link)`\n  font-size: 18px;\n  font-weight: bold;\n`;\n\nconst Description = styled.div`\n  margin-top: 8px;\n`;\n\nconst Divider = styled.div`\n  width: 50%;\n  height: 1px;\n  background-color: #eee;\n  margin: 32px 0;\n`;\n","import { FlexBox } from \"react-styled-flex\";\nimport styled from \"styled-components\";\nimport config from \"../config\";\n\nexport default function Footer() {\n  return (\n    <Wrapper as=\"footer\" justifyContent=\"center\" alignItems=\"flex-end\" padding=\"128px 0 24px 0\">\n      Copyright  2021 {config.user}\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled(FlexBox)`\n  flex: 1;\n  color: #999;\n`;\n","import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport NotFound from \"./compoment/not_found\";\nimport Post from \"./compoment/post\";\nimport Home from \"./compoment/home\";\nimport { createGlobalStyle } from \"styled-components\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\nimport { FlexBox } from \"react-styled-flex\";\nimport UserInfo from \"./compoment/info\";\nimport Footer from \"./compoment/footer\";\n\nconst queryClient = new QueryClient();\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <GlobalStyle />\n      <FlexBox justifyContent=\"center\" height=\"100%\">\n        <Router>\n          <FlexBox column width=\"100%\" marginTop=\"32px\" maxWidth=\"700px\" padding=\"0 20px\">\n            <UserInfo />\n            <Switch>\n              <Route exact path=\"/\">\n                <Home />\n              </Route>\n              <Route path=\"/post/:id(\\d+)\">\n                <Post />\n              </Route>\n              <Route path=\"*\">\n                <NotFound />\n              </Route>\n            </Switch>\n            <Footer />\n          </FlexBox>\n        </Router>\n      </FlexBox>\n    </QueryClientProvider>\n  );\n}\n\nconst GlobalStyle = createGlobalStyle`\nhtml, body {\n  background-color: #fff;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-size-adjust: 100%;\n  height: 100%;\n  overflow: hidden;\n}\nbody {\n  font-family: apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, PingFang SC, Microsoft YaHei, sans-serif;\n  font-size: 14px;\n  line-height: 1;\n  color: #333;\n  position: relative;\n  word-wrap: break-word;\n  overflow: auto;\n}\nbody,\nh1,\nh2,\nh3,\nh4,\nul,\nli,\np {\n  margin: 0;\n  padding: 0;\n  font-weight: normal;\n}\nbutton {\n  appearance: none;\n  cursor: pointer;\n  outline: none;\n  border: none;\n}\na {\n  color: inherit;\n  cursor: pointer;\n}\na:link {\n  text-decoration: none;\n}\na:hover {\n  text-decoration: underline;\n}\n#root {\n  height: 100%;\n}\n`;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import config from \"../config\";\nimport { useDiscussionCategoriesQuery } from \"./types-and-hooks\";\n\nexport default async function printDiscussionCategories(count = 10) {\n  const categories = await useDiscussionCategoriesQuery.fetcher({ owner: config.user, name: config.repository, count: count })();\n  console.log(categories);\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { encode } from \"./hepler/caesar_cipher\";\nimport printDiscussionCategories from \"./api/discussion_categories\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n\ndeclare global {\n  interface Window {\n    encode: (text: String) => string;\n    printDiscussionCategories: (count?: number) => void;\n  }\n}\nwindow.encode = encode;\nwindow.printDiscussionCategories = printDiscussionCategories;\n"],"sourceRoot":""}