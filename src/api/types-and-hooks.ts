import { useQuery, UseQueryOptions } from 'react-query';
import { fetchData } from '../hepler/fetcher';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO-8601 encoded date string. */
  Date: any;
  /** An ISO-8601 encoded UTC date string. */
  DateTime: any;
  /** A Git object ID. */
  GitObjectID: any;
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: any;
  /** Git SSH string */
  GitSSHRemote: any;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: any;
  /** A string containing HTML code. */
  HTML: any;
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: any;
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: any;
  /** A valid x509 certificate string */
  X509Certificate: any;
};



/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID'];
};


/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};




/** Autogenerated input type of AddAssigneesToAssignable */
export type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of AddDiscussionComment */
export type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: Maybe<Scalars['ID']>;
};


/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String'];
};


/** Autogenerated input type of AddLabelsToLabelable */
export type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID'];
};


/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: Maybe<Scalars['ID']>;
  /** The note on the card. */
  note?: Maybe<Scalars['String']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID'];
};


/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the column. */
  name: Scalars['String'];
  /** The Node ID of the project. */
  projectId: Scalars['ID'];
};


/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The SHA of the commit to comment on. */
  commitOID?: Maybe<Scalars['GitObjectID']>;
  /** The comment id to reply to. */
  inReplyTo?: Maybe<Scalars['ID']>;
  /** The relative path of the file to comment on. */
  path?: Maybe<Scalars['String']>;
  /** The line index in the diff to comment on. */
  position?: Maybe<Scalars['Int']>;
  /** The node ID of the pull request reviewing */
  pullRequestId?: Maybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: Maybe<Scalars['ID']>;
};


/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The review line comments. */
  comments?: Maybe<Array<Maybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: Maybe<Scalars['GitObjectID']>;
  /** The event to perform on the pull request review. */
  event?: Maybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The review line comment threads. */
  threads?: Maybe<Array<Maybe<DraftPullRequestReviewThread>>>;
};


/** Autogenerated input type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: Maybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: Maybe<Scalars['ID']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: Maybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: Maybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: Maybe<DiffSide>;
};


/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID'];
};


/** Autogenerated input type of AddUpvote */
export type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of AddVerifiableDomain */
export type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The URL of the domain */
  domain: Scalars['URI'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID'];
};




/** Autogenerated input type of ApproveDeployments */
export type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Optional comment for approving deployments */
  comment?: Maybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};


/** Autogenerated input type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID'];
};


/** Autogenerated input type of ArchiveRepository */
export type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID'];
};







/** Ordering options for Audit Log connections. */
export type AuditLogOrder = {
  /** The ordering direction. */
  direction?: Maybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: Maybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT'
}

























/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID'];
};


/** Autogenerated input type of ChangeUserStatus */
export type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: Maybe<Scalars['String']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: Maybe<Scalars['Boolean']>;
  /** A short description of your current status. */
  message?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: Maybe<Scalars['ID']>;
};




/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String'];
  /** Details about this annotation. */
  rawDetails?: Maybe<Scalars['String']>;
  /** The title that represents the annotation. */
  title?: Maybe<Scalars['String']>;
};


/** Represents an annotation's information level. */
export enum CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = 'FAILURE',
  /** An annotation indicating some information. */
  Notice = 'NOTICE',
  /** An annotation indicating an ignorable error. */
  Warning = 'WARNING'
}


/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: Maybe<Scalars['Int']>;
  /** The ending line of the range. */
  endLine: Scalars['Int'];
  /** The starting column of the range. */
  startColumn?: Maybe<Scalars['Int']>;
  /** The starting line of the range. */
  startLine: Scalars['Int'];
};


/** The possible states for a check suite or run conclusion. */
export enum CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check suite or run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check suite or run has failed. */
  Failure = 'FAILURE',
  /** The check suite or run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check suite or run was skipped. */
  Skipped = 'SKIPPED',
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check suite or run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check suite or run has succeeded. */
  Success = 'SUCCESS',
  /** The check suite or run has timed out. */
  TimedOut = 'TIMED_OUT'
}


/** Possible further actions the integrator can perform. */
export type CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String'];
};



/** The filters that are available when fetching check runs. */
export type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: Maybe<Scalars['Int']>;
  /** Filters the check runs by this name. */
  checkName?: Maybe<Scalars['String']>;
  /** Filters the check runs by this type. */
  checkType?: Maybe<CheckRunType>;
  /** Filters the check runs by this status. */
  status?: Maybe<CheckStatusState>;
};

/** Descriptive details about the check run. */
export type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: Maybe<Array<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: Maybe<Array<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String'];
  /** The details of the check run (supports Commonmark). */
  text?: Maybe<Scalars['String']>;
  /** A title to provide for this check run. */
  title: Scalars['String'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String'];
  /** A short image description. */
  caption?: Maybe<Scalars['String']>;
  /** The full URL of the image. */
  imageUrl: Scalars['URI'];
};

/** The possible types of check runs. */
export enum CheckRunType {
  /** Every check run available. */
  All = 'ALL',
  /** The latest check run. */
  Latest = 'LATEST'
}

/** The possible states for a check suite or run status. */
export enum CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run has been requested. */
  Requested = 'REQUESTED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}





/** The auto-trigger preferences that are available for check suites. */
export type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean'];
};



/** The filters that are available when fetching check suites. */
export type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: Maybe<Scalars['Int']>;
  /** Filters the check suites by this name. */
  checkName?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID'];
};


/** Autogenerated input type of CloneProject */
export type CloneProjectInput = {
  /** The description of the project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean'];
  /** The name of the project. */
  name: Scalars['String'];
  /** The visibility of the project, defaults to false (private). */
  public?: Maybe<Scalars['Boolean']>;
  /** The source project to clone. */
  sourceId: Scalars['ID'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID'];
};


/** Autogenerated input type of CloneTemplateRepository */
export type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: Maybe<Scalars['Boolean']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID'];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};



/** Autogenerated input type of CloseIssue */
export type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID'];
};


/** Autogenerated input type of ClosePullRequest */
export type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID'];
};





/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = 'ALL',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE'
}


/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = 'MANNEQUIN',
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author has no association with the repository. */
  None = 'NONE',
  /** Author is the owner of the repository. */
  Owner = 'OWNER'
}

/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You cannot update this comment */
  Denied = 'DENIED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'
}



/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: Maybe<Array<Scalars['String']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: Maybe<Scalars['ID']>;
};






/** Ordering options for commit contribution connections. */
export type CommitContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order commit contributions. */
  field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT',
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT'
}












/** Varying levels of contributions from none to many. */
export enum ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = 'FIRST_QUARTILE',
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = 'FOURTH_QUARTILE',
  /** No contributions occurred. */
  None = 'NONE',
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = 'SECOND_QUARTILE',
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = 'THIRD_QUARTILE'
}

/** Ordering options for contribution connections. */
export type ContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
};


/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID'];
};




/** Autogenerated input type of CreateBranchProtectionRule */
export type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: Maybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String'];
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: Maybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: Maybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;
};


/** Autogenerated input type of CreateCheckRun */
export type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: Maybe<Array<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: Maybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: Maybe<Scalars['URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID'];
  /** The name of the check. */
  name: Scalars['String'];
  /** Descriptive details about the run. */
  output?: Maybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status. */
  status?: Maybe<RequestableCheckStatusState>;
};


/** Autogenerated input type of CreateCheckSuite */
export type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of CreateContentAttachment */
export type CreateContentAttachmentInput = {
  /** The body of the content attachment, which may contain markdown. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The node ID of the content_reference. */
  contentReferenceId: Scalars['ID'];
  /** The title of the content attachment. */
  title: Scalars['String'];
};


/** Autogenerated input type of CreateDeployment */
export type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Short description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** Name for the target deployment environment. */
  environment?: Maybe<Scalars['String']>;
  /** JSON payload with extra information about the deployment. */
  payload?: Maybe<Scalars['String']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: Maybe<Array<Scalars['String']>>;
  /** Specifies a task to execute. */
  task?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of CreateDeploymentStatus */
export type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: Maybe<Scalars['String']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: Maybe<Scalars['String']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: Maybe<Scalars['String']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: Maybe<Scalars['String']>;
  /** The state of the deployment. */
  state: DeploymentStatusState;
};


/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};


/** Autogenerated input type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID'];
  /** The login of the new organization. */
  login: Scalars['String'];
  /** The profile name of the new organization. */
  profileName: Scalars['String'];
};


/** Autogenerated input type of CreateEnvironment */
export type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the environment. */
  name: Scalars['String'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID'];
};


/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: Maybe<Scalars['String']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title for the issue. */
  title: Scalars['String'];
};


/** Autogenerated input type of CreateLabel */
export type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String'];
  /** A brief description of the label, such as its purpose. */
  description?: Maybe<Scalars['String']>;
  /** The name of the label. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project. */
  name: Scalars['String'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: Maybe<Array<Scalars['ID']>>;
  /** The name of the GitHub-provided template. */
  template?: Maybe<ProjectTemplate>;
};


/** Autogenerated input type of CreatePullRequest */
export type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String'];
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: Maybe<Scalars['Boolean']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title of the pull request. */
  title: Scalars['String'];
};


/** Autogenerated input type of CreateRef */
export type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['GitObjectID'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of CreateRepository */
export type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: Maybe<Scalars['URI']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId?: Maybe<Scalars['ID']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: Maybe<Scalars['ID']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: Maybe<Scalars['Boolean']>;
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};


/** Autogenerated input type of CreateSponsorship */
export type CreateSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: Maybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: Maybe<Scalars['Boolean']>;
  /** The ID of user or organization who is acting as the sponsor, paying for the sponsorship. */
  sponsorId: Scalars['ID'];
  /** The ID of user or organization who is receiving the sponsorship. */
  sponsorableId: Scalars['ID'];
  /** The ID of tier to sponsor at. */
  tierId: Scalars['ID'];
};


/** Autogenerated input type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentInput = {
  /** The content of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the discussion to which the comment belongs. */
  discussionId: Scalars['ID'];
};


/** Autogenerated input type of CreateTeamDiscussion */
export type CreateTeamDiscussionInput = {
  /** The content of the discussion. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   */
  private?: Maybe<Scalars['Boolean']>;
  /** The ID of the team to which the discussion belongs. */
  teamId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};























/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The reason why the suggested topic is declined. */
  reason: TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** The possible base permissions for repositories. */
export enum DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN',
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE'
}


/** Autogenerated input type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of DeleteDeployment */
export type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteDiscussionComment */
export type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteDiscussion */
export type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteEnvironment */
export type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID'];
};


/** Autogenerated input type of DeleteIssueComment */
export type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteIssue */
export type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID'];
};


/** Autogenerated input type of DeleteLabel */
export type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeletePackageVersion */
export type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID'];
};


/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID'];
};


/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
};


/** Autogenerated input type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID'];
};


/** Autogenerated input type of DeleteRef */
export type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID'];
};


/** Autogenerated input type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion ID to delete. */
  id: Scalars['ID'];
};


/** Autogenerated input type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID'];
};

















/** Ordering options for deployment connections */
export type DeploymentOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order deployments by. */
  field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT'
}




/** The possible protection rule types. */
export enum DeploymentProtectionRuleType {
  /** Required reviewers */
  RequiredReviewers = 'REQUIRED_REVIEWERS',
  /** Wait timer */
  WaitTimer = 'WAIT_TIMER'
}







/** The possible states for a deployment review. */
export enum DeploymentReviewState {
  /** The deployment was approved. */
  Approved = 'APPROVED',
  /** The deployment was rejected. */
  Rejected = 'REJECTED'
}




/** The possible states in which a deployment can be. */
export enum DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}




/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}

/** The possible sides of a diff. */
export enum DiffSide {
  /** The left side of the diff. */
  Left = 'LEFT',
  /** The right side of the diff. */
  Right = 'RIGHT'
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID'];
};












/** Ways in which lists of discussions can be ordered upon return. */
export type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: OrderDirection;
  /** The field by which to order discussions. */
  field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export enum DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order discussions by most recent modification time. */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};


/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: Maybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: Maybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: Maybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  commitBody?: Maybe<Scalars['String']>;
  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  commitHeadline?: Maybe<Scalars['String']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: Maybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID'];
};








/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible administrator roles in an enterprise account. */
export enum EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER',
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER'
}



/** The possible values for the enterprise base repository permission setting. */
export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE',
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE'
}

/** The possible values for an enabled/disabled enterprise setting. */
export enum EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}





/** Ordering options for enterprise member connections. */
export type EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise members by. */
  field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order enterprise members by login */
  Login = 'LOGIN'
}

/** The possible values for the enterprise members can create repositories setting. */
export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC'
}

/** The possible values for the members can make purchases setting. */
export enum EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED'
}
















/** Ordering options for Enterprise Server installation connections. */
export type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME'
}







/** Ordering options for Enterprise Server user account email connections. */
export type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order emails by. */
  field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL'
}

/** Ordering options for Enterprise Server user account connections. */
export type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts by. */
  field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT'
}




/** Ordering options for Enterprise Server user accounts upload connections. */
export type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE',
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS'
}




/** The possible roles for enterprise membership. */
export enum EnterpriseUserAccountMembershipRole {
  /** The user is a member of the enterprise membership. */
  Member = 'MEMBER',
  /** The user is an owner of the enterprise membership. */
  Owner = 'OWNER'
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER'
}









/** The possible viewed states of a file . */
export enum FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = 'DISMISSED',
  /** The file has not been marked as viewed. */
  Unviewed = 'UNVIEWED',
  /** The file has been marked as viewed. */
  Viewed = 'VIEWED'
}

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the user to follow. */
  userId: Scalars['ID'];
};





/** The possible funding platforms for repository funding links. */
export enum FundingPlatform {
  /** Community Bridge funding platform. */
  CommunityBridge = 'COMMUNITY_BRIDGE',
  /** Custom funding platform. */
  Custom = 'CUSTOM',
  /** GitHub funding platform. */
  Github = 'GITHUB',
  /** IssueHunt funding platform. */
  Issuehunt = 'ISSUEHUNT',
  /** Ko-fi funding platform. */
  KoFi = 'KO_FI',
  /** Liberapay funding platform. */
  Liberapay = 'LIBERAPAY',
  /** Open Collective funding platform. */
  OpenCollective = 'OPEN_COLLECTIVE',
  /** Otechie funding platform. */
  Otechie = 'OTECHIE',
  /** Patreon funding platform. */
  Patreon = 'PATREON',
  /** Tidelift funding platform. */
  Tidelift = 'TIDELIFT'
}









/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The privacy of a Gist */
export enum GistPrivacy {
  /** Gists that are public and secret */
  All = 'ALL',
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET'
}










/** The state of a Git signature. */
export enum GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Valid signature, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Valid signature and verified by GitHub */
  Valid = 'VALID'
}









/** The possible states in which authentication can be configured with an identity provider. */
export enum IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED'
}

/** Autogenerated input type of ImportProject */
export type ImportProjectInput = {
  /** The description of Project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String'];
  /** Whether the Project is public or not. */
  public?: Maybe<Scalars['Boolean']>;
};


/** Autogenerated input type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The email of the person to invite as an administrator. */
  email?: Maybe<Scalars['String']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of a user to invite as an administrator. */
  invitee?: Maybe<Scalars['String']>;
  /** The role of the administrator. */
  role?: Maybe<EnterpriseAdministratorRole>;
};


/** The possible values for the IP allow list enabled setting. */
export enum IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}




/** Ordering options for IP allow list entry connections. */
export type IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = 'ALLOW_LIST_VALUE',
  /** Order IP allow list entries by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export enum IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}






/** Ways in which lists of issue comments can be ordered upon return. */
export type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issue comments by. */
  field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export enum IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = 'UPDATED_AT'
}




/** Ways in which to filter lists of issues. */
export type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: Maybe<Scalars['String']>;
  /** List issues created by given name. */
  createdBy?: Maybe<Scalars['String']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: Maybe<Array<Scalars['String']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: Maybe<Scalars['String']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: Maybe<Scalars['String']>;
  /** List issues that have been updated at or after the given date. */
  since?: Maybe<Scalars['DateTime']>;
  /** List issues filtered by the list of states given. */
  states?: Maybe<Array<IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: Maybe<Scalars['Boolean']>;
};


/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issues by. */
  field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  /** Order issues by comment count */
  Comments = 'COMMENTS',
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of an issue. */
export enum IssueState {
  /** An issue that has been closed */
  Closed = 'CLOSED',
  /** An issue that is still open */
  Open = 'OPEN'
}








/** The possible item types found in a timeline. */
export enum IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}





/** Ways in which lists of labels can be ordered upon return. */
export type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: OrderDirection;
  /** The field in which to order labels by. */
  field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order labels by name */
  Name = 'NAME'
}






/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order languages by. */
  field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE'
}



/** Autogenerated input type of LinkRepositoryToProject */
export type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A reason for why the item will be locked. */
  lockReason?: Maybe<LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID'];
};


/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED'
}




/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID'];
};


/** Autogenerated input type of MarkFileAsViewed */
export type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};


/** Autogenerated input type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID'];
};












/** Autogenerated input type of MergeBranch */
export type MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: Maybe<Scalars['String']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: Maybe<Scalars['String']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of MergePullRequest */
export type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: Maybe<Scalars['String']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: Maybe<Scalars['String']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: Maybe<Scalars['GitObjectID']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: Maybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID'];
};


/** Detailed status information about a pull request merge. */
export enum MergeStateStatus {
  /** The head ref is out of date. */
  Behind = 'BEHIND',
  /** The merge is blocked. */
  Blocked = 'BLOCKED',
  /** Mergeable and passing commit status. */
  Clean = 'CLEAN',
  /** The merge commit cannot be cleanly created. */
  Dirty = 'DIRTY',
  /** The merge is blocked due to the pull request being a draft. */
  Draft = 'DRAFT',
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = 'HAS_HOOKS',
  /** The state cannot currently be determined. */
  Unknown = 'UNKNOWN',
  /** Mergeable with non-passing commit status. */
  Unstable = 'UNSTABLE'
}

/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN'
}






/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order milestones by. */
  field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by their number. */
  Number = 'NUMBER',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of a milestone. */
export enum MilestoneState {
  /** A milestone that has been closed. */
  Closed = 'CLOSED',
  /** A milestone that is still open. */
  Open = 'OPEN'
}



/** Autogenerated input type of MinimizeComment */
export type MinimizeCommentInput = {
  /** The classification of comment */
  classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: Maybe<Scalars['ID']>;
  /** The id of the card to move. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID'];
};


/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: Maybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to move. */
  columnId: Scalars['ID'];
};





/** The possible values for the notification restriction setting. */
export enum NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}



/** The state of an OAuth Application when it was created. */
export enum OauthApplicationCreateAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION',
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED'
}

/** The corresponding operation type for the action */
export enum OperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER'
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}



/** The permissions available to members on an Organization. */
export enum OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}





/** The billing plans available for organizations. */
export enum OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Free Plan */
  Free = 'FREE',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED'
}













/** The reason a billing manager was removed from an Organization. */
export enum OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}


/** The type of membership a user has with an Organization. */
export enum OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason a member was removed from an Organization. */
export enum OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** User account has been deleted */
  UserAccountDeleted = 'USER_ACCOUNT_DELETED'
}


/** The type of membership a user has with an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason an outside collaborator was removed from an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}








/** The default permission a repository can have in an Organization. */
export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE',
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE'
}


/** The permissions available to members on an Organization. */
export enum OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}


/** The permissions available for repository creation on an Organization. */
export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating internal repositories. */
  Internal = 'INTERNAL',
  /** All organization members are allowed to create any repositories. */
  None = 'NONE',
  /** All organization members are restricted from creating private repositories. */
  Private = 'PRIVATE',
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = 'PRIVATE_INTERNAL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC',
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = 'PUBLIC_INTERNAL',
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = 'PUBLIC_PRIVATE'
}













/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE'
}

/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = 'EMAIL',
  /** The invitation was to an existing user. */
  User = 'USER'
}



/** The possible roles within an organization for its members. */
export enum OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN',
  /** The user is a member of the organization. */
  Member = 'MEMBER'
}

/** The possible values for the members can create repositories setting on an organization. */
export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Members will be able to create only internal repositories. */
  Internal = 'INTERNAL',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE'
}

/** Ordering options for organization connections. */
export type OrganizationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order organizations by. */
  field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN'
}









/** Ways in which lists of package files can be ordered upon return. */
export type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: Maybe<OrderDirection>;
  /** The field in which to order package files by. */
  field?: Maybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Ways in which lists of packages can be ordered upon return. */
export type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: Maybe<OrderDirection>;
  /** The field in which to order packages by. */
  field?: Maybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = 'CREATED_AT'
}




/** The possible types of a package. */
export enum PackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /** A docker image. */
  Docker = 'DOCKER',
  /** A maven package. */
  Maven = 'MAVEN',
  /** An npm package. */
  Npm = 'NPM',
  /** A nuget package. */
  Nuget = 'NUGET',
  /** A python package. */
  Pypi = 'PYPI',
  /** A rubygems package. */
  Rubygems = 'RUBYGEMS'
}




/** Ways in which lists of package versions can be ordered upon return. */
export type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: Maybe<OrderDirection>;
  /** The field in which to order package versions by. */
  field?: Maybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = 'CREATED_AT'
}





/** Autogenerated input type of PinIssue */
export type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID'];
};





/** Represents items that can be pinned to a profile page or dashboard. */
export enum PinnableItemType {
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A team. */
  Team = 'TEAM',
  /** A user. */
  User = 'USER'
}




/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = 'BLUE_MINT',
  /** A gradient of blue to purple */
  BluePurple = 'BLUE_PURPLE',
  /** A gradient of pink to blue */
  PinkBlue = 'PINK_BLUE',
  /** A gradient of purple to coral */
  PurpleCoral = 'PURPLE_CORAL',
  /** A gradient of red to orange */
  RedOrange = 'RED_ORANGE'
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = 'CHEVRON_UP',
  /** A hollow dot pattern */
  Dot = 'DOT',
  /** A solid dot pattern */
  DotFill = 'DOT_FILL',
  /** A heart pattern */
  HeartFill = 'HEART_FILL',
  /** A plus sign pattern */
  Plus = 'PLUS',
  /** A lightning bolt pattern */
  Zap = 'ZAP'
}












/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED'
}



/** An issue or PR and its owning repository to be used in a project card. */
export type ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String'];
};


/** Various content states of a ProjectCard */
export enum ProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED'
}




/** A project column and a list of its issues and PRs. */
export type ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String'];
  /** A list of issues and pull requests in the column. */
  issues?: Maybe<Array<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = 'DONE',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards still to be worked on */
  Todo = 'TODO'
}



/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by name */
  Name = 'NAME',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT'
}



/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  /** The project is closed. */
  Closed = 'CLOSED',
  /** The project is open. */
  Open = 'OPEN'
}

/** GitHub-provided templates for Projects */
export enum ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE'
}















/** Represents available types of methods to use when merging a pull request. */
export enum PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH'
}

/** Ways in which lists of issues can be ordered upon return. */
export type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: OrderDirection;
  /** The field in which to order pull requests by. */
  field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT'
}





/** The possible states of a pull request review comment. */
export enum PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED'
}



/** The review status of a pull request. */
export enum PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = 'APPROVED',
  /** Changes have been requested on the pull request. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review is required before the pull request can be merged. */
  ReviewRequired = 'REVIEW_REQUIRED'
}


/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES'
}

/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED',
  /** A review that has not yet been submitted. */
  Pending = 'PENDING'
}





/** The possible states of a pull request. */
export enum PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}








/** The possible item types found in a timeline. */
export enum PullRequestTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** The possible target states when updating a pull request. */
export enum PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}













/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP'
}



/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT'
}








/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
  /** The field in which to order refs by. */
  field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL',
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE'
}

/** A ref update */
export type RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['GitObjectID'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: Maybe<Scalars['GitObjectID']>;
  /** Force a non fast-forward update. */
  force?: Maybe<Scalars['Boolean']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['GitRefname'];
};




/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
};


/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID'];
};


/** Autogenerated input type of RejectDeployments */
export type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Optional comment for rejecting deployments */
  comment?: Maybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};








/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME'
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String'];
};


/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID'];
};


/** Autogenerated input type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID'];
};


/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String'];
};


/** Autogenerated input type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID'];
};


/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID'];
};


/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID'];
};


/** Autogenerated input type of RemoveUpvote */
export type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID'];
};





/** Autogenerated input type of ReopenIssue */
export type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID'];
};


/** Autogenerated input type of ReopenPullRequest */
export type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID'];
};




/** The privacy of a repository */
export enum RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}


/** The privacy of a repository */
export enum RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}



/** The privacy of a repository */
export enum RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}


/** The merge options available for pull requests to this repository. */
export enum RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH'
}












/** The privacy of a repository */
export enum RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}


/** The privacy of a repository */
export enum RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}


/** The privacy of a repository */
export enum RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}


/** The reasons a piece of content can be reported or minimized. */
export enum ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** A duplicated piece of content */
  Duplicate = 'DUPLICATE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED',
  /** A spammy piece of content */
  Spam = 'SPAM'
}


/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER'
}






/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** Created the repository */
  Repository = 'REPOSITORY'
}






/** A repository interaction limit. */
export enum RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = 'COLLABORATORS_ONLY',
  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */
  ContributorsOnly = 'CONTRIBUTORS_ONLY',
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = 'EXISTING_USERS',
  /** No interaction limits are enabled. */
  NoLimit = 'NO_LIMIT'
}

/** The length for a repository interaction limit to be enabled for. */
export enum RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = 'ONE_DAY',
  /** The interaction limit will expire after 1 month. */
  OneMonth = 'ONE_MONTH',
  /** The interaction limit will expire after 1 week. */
  OneWeek = 'ONE_WEEK',
  /** The interaction limit will expire after 6 months. */
  SixMonths = 'SIX_MONTHS',
  /** The interaction limit will expire after 3 days. */
  ThreeDays = 'THREE_DAYS'
}

/** Indicates where an interaction limit is configured. */
export enum RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = 'ORGANIZATION',
  /** A limit that is configured at the repository level. */
  Repository = 'REPOSITORY',
  /** A limit that is configured at the user-wide level. */
  User = 'USER'
}




/** Ordering options for repository invitation connections. */
export type RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository invitations by. */
  field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repository invitations by invitee login */
  InviteeLogin = 'INVITEE_LOGIN'
}

/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING',
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME'
}


/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}


/** The access level to a repository */
export enum RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE'
}

/** The privacy of a repository */
export enum RepositoryPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}




/** The repository's visibility level. */
export enum RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}






/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The Node IDs of the team to request. */
  teamIds?: Maybe<Array<Scalars['ID']>>;
  /** Add users to the set rather than replace. */
  union?: Maybe<Scalars['Boolean']>;
  /** The Node IDs of the user to request. */
  userIds?: Maybe<Array<Scalars['ID']>>;
};


/** The possible states that can be requested when creating a check run. */
export enum RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}



/** Autogenerated input type of RerequestCheckSuite */
export type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of ResolveReviewThread */
export type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID'];
};














/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512'
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512'
}




/** Ordering options for saved reply connections. */
export type SavedReplyOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order saved replies by. */
  field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}




/** Represents the individual results of a search. */
export enum SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = 'DISCUSSION',
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER'
}



/** The possible ecosystems of a security vulnerability's package. */
export enum SecurityAdvisoryEcosystem {
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS'
}



/** An advisory identifier to filter results on. */
export type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String'];
};

/** Identifier formats available for advisories. */
export enum SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA'
}

/** Ordering options for security advisory connections */
export type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security advisories by. */
  field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT'
}




/** Severity of the vulnerability. */
export enum SecurityAdvisorySeverity {
  /** Critical. */
  Critical = 'CRITICAL',
  /** High. */
  High = 'HIGH',
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE'
}




/** Ordering options for security vulnerability connections */
export type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: Maybe<Scalars['String']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['URI'];
};


/** Autogenerated input type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID'];
};


/** Autogenerated input type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of SetUserInteractionLimit */
export type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: Maybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID'];
};






/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type SponsorOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsor entities by. */
  field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export enum SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN',
  /** Order sponsors by their relevance to the viewer. */
  Relevance = 'RELEVANCE'
}





/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type SponsorableOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export enum SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN'
}


/** The possible actions that GitHub Sponsors activities can represent. */
export enum SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',
  /** The activity was starting a sponsorship. */
  NewSponsorship = 'NEW_SPONSORSHIP',
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = 'PENDING_CHANGE',
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = 'REFUND',
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = 'TIER_CHANGE'
}



/** Ordering options for GitHub Sponsors activity connections. */
export type SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order activity by. */
  field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export enum SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = 'TIMESTAMP'
}

/** The possible time periods for which Sponsors activities can be requested. */
export enum SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = 'ALL',
  /** The previous calendar day. */
  Day = 'DAY',
  /** The previous thirty days. */
  Month = 'MONTH',
  /** The previous seven days. */
  Week = 'WEEK'
}


/** The different kinds of goals a GitHub Sponsors member can have. */
export enum SponsorsGoalKind {
  /** The goal is about getting a certain dollar amount from sponsorships each month. */
  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'
}






/** Ordering options for Sponsors tiers connections. */
export type SponsorsTierOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order tiers by. */
  field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'
}







/** Ordering options for sponsorship newsletter connections. */
export type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export enum SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Ordering options for sponsorship connections. */
export type SponsorshipOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship by. */
  field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The privacy of a sponsorship */
export enum SponsorshipPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT'
}












/** The possible commit status states. */
export enum StatusState {
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS'
}

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: Maybe<Scalars['ID']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: Maybe<Scalars['ID']>;
};







/** The possible states of a subscription. */
export enum SubscriptionState {
  /** The User is never notified. */
  Ignored = 'IGNORED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED'
}













/** Ways in which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER'
}



/** Ways in which team discussion connections can be ordered. */
export type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT'
}




/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order team members by. */
  field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order team members by login */
  Login = 'LOGIN'
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER'
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = 'ALL',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE'
}

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME'
}

/** The possible team privacy values. */
export enum TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE'
}





/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible team review assignment algorithms */
export enum TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = 'LOAD_BALANCE',
  /** Alternate reviews between each team member */
  RoundRobin = 'ROUND_ROBIN'
}

/** The role of a user on a team. */
export enum TeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER'
}





/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = 'NOT_RELEVANT',
  /** The viewer does not like the suggested topic. */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /** The suggested topic is too general for the repository. */
  TooGeneral = 'TOO_GENERAL',
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = 'TOO_SPECIFIC'
}

/** Autogenerated input type of TransferIssue */
export type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID'];
};






/** Autogenerated input type of UnarchiveRepository */
export type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID'];
};



/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID'];
};





/** Autogenerated input type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID'];
};



/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID'];
};


/** Autogenerated input type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};


/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID'];
};



/** Autogenerated input type of UnminimizeComment */
export type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};


/** Autogenerated input type of UnpinIssue */
export type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID'];
};



/** Autogenerated input type of UnresolveReviewThread */
export type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID'];
};





/** Autogenerated input type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: Maybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: Maybe<Scalars['Boolean']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: Maybe<Scalars['String']>;
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: Maybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: Maybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;
};


/** Autogenerated input type of UpdateCheckRun */
export type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: Maybe<Array<CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: Maybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: Maybe<Scalars['URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The name of the check. */
  name?: Maybe<Scalars['String']>;
  /** Descriptive details about the run. */
  output?: Maybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status. */
  status?: Maybe<RequestableCheckStatusState>;
};


/** Autogenerated input type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of UpdateDiscussionComment */
export type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID'];
};


/** Autogenerated input type of UpdateDiscussion */
export type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: Maybe<Scalars['String']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: Maybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID'];
  /** The new discussion title. */
  title?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String'];
  /** The new role for the Enterprise administrator. */
  role: EnterpriseAdministratorRole;
};


/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: Maybe<Scalars['Boolean']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: Maybe<Scalars['Boolean']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: Maybe<Scalars['Boolean']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>;
  /** The name of the enterprise. */
  name?: Maybe<Scalars['String']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};


/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: EnterpriseEnabledSettingValue;
};


/** Autogenerated input type of UpdateEnvironment */
export type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID'];
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: Maybe<Array<Scalars['ID']>>;
  /** The wait timer in minutes. */
  waitTimer?: Maybe<Scalars['Int']>;
};


/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list enabled setting. */
  settingValue: IpAllowListEnabledSettingValue;
};


/** Autogenerated input type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};


/** Autogenerated input type of UpdateIssueComment */
export type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID'];
};


/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The desired issue state. */
  state?: Maybe<IssueState>;
  /** The title for the issue. */
  title?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateLabel */
export type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: Maybe<Scalars['String']>;
  /** A brief description of the label, such as its purpose. */
  description?: Maybe<Scalars['String']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID'];
  /** The updated name of the label. */
  name?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID'];
  /** The value for the restrict notifications setting. */
  settingValue: NotificationRestrictionSettingValue;
};


/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: Maybe<Scalars['Boolean']>;
  /** The note of ProjectCard. */
  note?: Maybe<Scalars['String']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID'];
};


/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project column. */
  name: Scalars['String'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID'];
};


/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project. */
  name?: Maybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
  /** Whether the project is public or not. */
  public?: Maybe<Scalars['Boolean']>;
  /** Whether the project is open or closed. */
  state?: Maybe<ProjectState>;
};


/** Autogenerated input type of UpdatePullRequest */
export type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: Maybe<Scalars['String']>;
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
  /** The target state of the pull request. */
  state?: Maybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID'];
};


/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};


/** Autogenerated input type of UpdateRef */
export type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: Maybe<Scalars['Boolean']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['GitObjectID'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID'];
};


/** Autogenerated input type of UpdateRefs */
export type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of ref updates. */
  refUpdates: Array<RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};


/** Autogenerated input type of UpdateRepository */
export type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: Maybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: Maybe<Scalars['URI']>;
  /** The new name of the repository. */
  name?: Maybe<Scalars['String']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: Maybe<Scalars['Boolean']>;
};


/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID'];
};


/** Autogenerated input type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID'];
};


/** Autogenerated input type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: Maybe<Scalars['String']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: Maybe<Scalars['Boolean']>;
  /** The updated title of the discussion. */
  title?: Maybe<Scalars['String']>;
};


/** Autogenerated input type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: Maybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: Maybe<Scalars['Boolean']>;
  /** The number of team members to assign */
  teamMemberCount?: Maybe<Scalars['Int']>;
};


/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']>;
};



/** The possible durations that a user can be blocked for. */
export enum UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS'
}











/** Ordering options for user status connections. */
export type UserStatusOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user statuses by. */
  field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}




/** Ordering options for verifiable domain connections. */
export type VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order verifiable domains by. */
  field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export enum VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = 'CREATED_AT',
  /** Order verifiable domains by the domain name. */
  Domain = 'DOMAIN'
}


/** Autogenerated input type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID'];
};







export type UserQueryVariables = Exact<{
  user: Scalars['String'];
}>;


export type UserQuery = { data?: Maybe<{ websiteUrl?: Maybe<any>, url: any, description?: Maybe<string> }> };

export type DiscussionCategoriesQueryVariables = Exact<{
  owner: Scalars['String'];
  name: Scalars['String'];
  count: Scalars['Int'];
}>;


export type DiscussionCategoriesQuery = { repository?: Maybe<{ discussionCategories: { nodes?: Maybe<Array<Maybe<{ id: string, name: string }>>> } }> };

export type DiscussionsQueryVariables = Exact<{
  owner: Scalars['String'];
  name: Scalars['String'];
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<DiscussionOrder>;
  labelsCount: Scalars['Int'];
}>;


export type DiscussionsQuery = { repository?: Maybe<{ discussions: { totalCount: number, pageInfo: { hasPreviousPage: boolean, startCursor?: Maybe<string>, hasNextPage: boolean, endCursor?: Maybe<string> }, nodes?: Maybe<Array<Maybe<{ number: number, title: string, createdAt: any, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> }>>> } }> };

export type LabelItemFragment = { color: string, name: string };

export type PostItemFragment = { number: number, title: string, createdAt: any, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> };

export type DiscussionQueryVariables = Exact<{
  owner: Scalars['String'];
  name: Scalars['String'];
  number: Scalars['Int'];
  labelsCount: Scalars['Int'];
}>;


export type DiscussionQuery = { repository?: Maybe<{ discussion?: Maybe<{ number: number, title: string, updatedAt: any, bodyHTML: any, url: any, upvoteCount: number, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> }> }> };

export type PostDetailFragment = { number: number, title: string, updatedAt: any, bodyHTML: any, url: any, upvoteCount: number, labels?: Maybe<{ nodes?: Maybe<Array<Maybe<{ color: string, name: string }>>> }> };

export const LabelItemFragmentDoc = `
    fragment LabelItem on Label {
  color
  name
}
    `;
export const PostItemFragmentDoc = `
    fragment PostItem on Discussion {
  number
  title
  createdAt
  labels(first: $labelsCount) {
    nodes {
      ...LabelItem
    }
  }
}
    ${LabelItemFragmentDoc}`;
export const PostDetailFragmentDoc = `
    fragment PostDetail on Discussion {
  number
  title
  updatedAt
  bodyHTML
  url
  upvoteCount
  labels(first: $labelsCount) {
    nodes {
      ...LabelItem
    }
  }
}
    ${LabelItemFragmentDoc}`;
export const UserDocument = `
    query user($user: String!) {
  data: user(login: $user) {
    websiteUrl
    url
    description: bio
  }
}
    `;
export const useUserQuery = <
      TData = UserQuery,
      TError = unknown
    >(
      variables: UserQueryVariables, 
      options?: UseQueryOptions<UserQuery, TError, TData>
    ) => 
    useQuery<UserQuery, TError, TData>(
      ['user', variables],
      fetchData<UserQuery, UserQueryVariables>(UserDocument, variables),
      options
    );
useUserQuery.fetcher = (variables: UserQueryVariables) => fetchData<UserQuery, UserQueryVariables>(UserDocument, variables);
export const DiscussionCategoriesDocument = `
    query discussionCategories($owner: String!, $name: String!, $count: Int!) {
  repository(owner: $owner, name: $name) {
    discussionCategories(first: $count) {
      nodes {
        id
        name
      }
    }
  }
}
    `;
export const useDiscussionCategoriesQuery = <
      TData = DiscussionCategoriesQuery,
      TError = unknown
    >(
      variables: DiscussionCategoriesQueryVariables, 
      options?: UseQueryOptions<DiscussionCategoriesQuery, TError, TData>
    ) => 
    useQuery<DiscussionCategoriesQuery, TError, TData>(
      ['discussionCategories', variables],
      fetchData<DiscussionCategoriesQuery, DiscussionCategoriesQueryVariables>(DiscussionCategoriesDocument, variables),
      options
    );
useDiscussionCategoriesQuery.fetcher = (variables: DiscussionCategoriesQueryVariables) => fetchData<DiscussionCategoriesQuery, DiscussionCategoriesQueryVariables>(DiscussionCategoriesDocument, variables);
export const DiscussionsDocument = `
    query discussions($owner: String!, $name: String!, $after: String, $before: String, $categoryId: ID, $first: Int, $last: Int, $orderBy: DiscussionOrder, $labelsCount: Int!) {
  repository(owner: $owner, name: $name) {
    discussions(
      after: $after
      before: $before
      categoryId: $categoryId
      first: $first
      last: $last
      orderBy: $orderBy
    ) {
      pageInfo {
        hasPreviousPage
        startCursor
        hasNextPage
        endCursor
      }
      totalCount
      nodes {
        ...PostItem
      }
    }
  }
}
    ${PostItemFragmentDoc}`;
export const useDiscussionsQuery = <
      TData = DiscussionsQuery,
      TError = unknown
    >(
      variables: DiscussionsQueryVariables, 
      options?: UseQueryOptions<DiscussionsQuery, TError, TData>
    ) => 
    useQuery<DiscussionsQuery, TError, TData>(
      ['discussions', variables],
      fetchData<DiscussionsQuery, DiscussionsQueryVariables>(DiscussionsDocument, variables),
      options
    );
useDiscussionsQuery.fetcher = (variables: DiscussionsQueryVariables) => fetchData<DiscussionsQuery, DiscussionsQueryVariables>(DiscussionsDocument, variables);
export const DiscussionDocument = `
    query discussion($owner: String!, $name: String!, $number: Int!, $labelsCount: Int!) {
  repository(owner: $owner, name: $name) {
    discussion(number: $number) {
      ...PostDetail
    }
  }
}
    ${PostDetailFragmentDoc}`;
export const useDiscussionQuery = <
      TData = DiscussionQuery,
      TError = unknown
    >(
      variables: DiscussionQueryVariables, 
      options?: UseQueryOptions<DiscussionQuery, TError, TData>
    ) => 
    useQuery<DiscussionQuery, TError, TData>(
      ['discussion', variables],
      fetchData<DiscussionQuery, DiscussionQueryVariables>(DiscussionDocument, variables),
      options
    );
useDiscussionQuery.fetcher = (variables: DiscussionQueryVariables) => fetchData<DiscussionQuery, DiscussionQueryVariables>(DiscussionDocument, variables);